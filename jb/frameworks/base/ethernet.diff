diff --git a/Android.mk b/Android.mk
index d38150f..c738c9c 100644
--- a/Android.mk
+++ b/Android.mk
@@ -221,6 +221,7 @@ LOCAL_SRC_FILES += \
 	telephony/java/com/android/internal/telephony/IExtendedNetworkService.aidl \
 	wifi/java/android/net/wifi/IWifiManager.aidl \
 	wifi/java/android/net/wifi/p2p/IWifiP2pManager.aidl \
+	ethernet/java/android/net/ethernet/IEthernetManager.aidl \
 	voip/java/android/net/sip/ISipSession.aidl \
 	voip/java/android/net/sip/ISipSessionListener.aidl \
 	voip/java/android/net/sip/ISipService.aidl
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 95b6bed..37e1a41 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -74,6 +74,8 @@ import android.net.wifi.IWifiManager;
 import android.net.wifi.WifiManager;
 import android.net.wifi.p2p.IWifiP2pManager;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.net.ethernet.IEthernetManager;
+import android.net.ethernet.EthernetManager;
 import android.nfc.NfcManager;
 import android.os.Binder;
 import android.os.Bundle;
@@ -518,6 +520,13 @@ class ContextImpl extends Context {
                     return new WifiP2pManager(service);
                 }});
 
+        registerService(ETHERNET_SERVICE, new ServiceFetcher() {
+                public Object createService(ContextImpl ctx) {
+                    IBinder b = ServiceManager.getService(ETHERNET_SERVICE);
+                    IEthernetManager service = IEthernetManager.Stub.asInterface(b);
+                    return new EthernetManager(ctx.getOuterContext(), service);
+                }});
+
         registerService(WINDOW_SERVICE, new ServiceFetcher() {
                 public Object getService(ContextImpl ctx) {
                     Display display = ctx.mDisplay;
diff --git a/core/java/android/app/DownloadManager.java b/core/java/android/app/DownloadManager.java
index 6cf4dd0..d738cb6 100644
--- a/core/java/android/app/DownloadManager.java
+++ b/core/java/android/app/DownloadManager.java
@@ -351,6 +351,13 @@ public class DownloadManager {
          */
         public static final int NETWORK_BLUETOOTH = 1 << 2;
 
+        /**
+         * Bit flag for {@link #setAllowedNetworkTypes} corresponding to
+         * {@link ConnectivityManager#TYPE_ETHERNET}.
+         * @hide
+         */
+        public static final int NETWORK_ETHERNET = 1 << 3;
+
         private Uri mUri;
         private Uri mDestinationUri;
         private List<Pair<String, String>> mRequestHeaders = new ArrayList<Pair<String, String>>();
diff --git a/core/java/android/content/Context.java b/core/java/android/content/Context.java
index 7aa2507..85722c6 100644
--- a/core/java/android/content/Context.java
+++ b/core/java/android/content/Context.java
@@ -1759,6 +1759,9 @@ public abstract class Context {
      *  <dt> {@link #WIFI_SERVICE} ("wifi")
      *  <dd> A {@link android.net.wifi.WifiManager WifiManager} for management of
      * Wi-Fi connectivity.
+     *  <dt> {@link #ETHERNET_SERVICE} ("ethernet")
+     *  <dd> A {@link android.net.ethernet.EthernetManager EthernetManager} for management of
+     * Ethernet connectivity.
      * <dt> {@link #INPUT_METHOD_SERVICE} ("input_method")
      * <dd> An {@link android.view.inputmethod.InputMethodManager InputMethodManager}
      * for management of input methods.
@@ -1805,6 +1808,8 @@ public abstract class Context {
      * @see android.net.ConnectivityManager
      * @see #WIFI_SERVICE
      * @see android.net.wifi.WifiManager
+     * @see #ETHERNET_SERVICE
+     * @see android.net.ethernet.EthernetManager
      * @see #AUDIO_SERVICE
      * @see android.media.AudioManager
      * @see #MEDIA_ROUTER_SERVICE
@@ -2051,6 +2056,16 @@ public abstract class Context {
 
     /**
      * Use with {@link #getSystemService} to retrieve a {@link
+     * android.net.ethernet.EthernetManager} for handling management of
+     * Ethernet access.
+     *
+     * @see #getSystemService
+     * @see android.net.ethernet.EthernetManager
+     */
+    public static final String ETHERNET_SERVICE = "ethernet";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
      * android.net.nsd.NsdManager} for handling management of network service
      * discovery
      *
diff --git a/core/java/android/content/pm/PackageManager.java b/core/java/android/content/pm/PackageManager.java
index 8ba1988..e87b268 100644
--- a/core/java/android/content/pm/PackageManager.java
+++ b/core/java/android/content/pm/PackageManager.java
@@ -1109,6 +1109,13 @@ public abstract class PackageManager {
 
     /**
      * Feature for {@link #getSystemAvailableFeatures} and
+     * {@link #hasSystemFeature}: The device supports Ethernet (802.3) networking.
+     */
+    @SdkConstant(SdkConstantType.FEATURE)
+    public static final String FEATURE_ETHERNET = "android.hardware.ethernet";
+
+    /**
+     * Feature for {@link #getSystemAvailableFeatures} and
      * {@link #hasSystemFeature}: This is a device dedicated to showing UI
      * on a television.  Television here is defined to be a typical living
      * room television experience: displayed on a big screen, where the user
diff --git a/core/java/android/net/ConnectivityManager.java b/core/java/android/net/ConnectivityManager.java
index 6ff1a33..44029fe 100644
--- a/core/java/android/net/ConnectivityManager.java
+++ b/core/java/android/net/ConnectivityManager.java
@@ -758,6 +758,17 @@ public class ConnectivityManager {
     /**
      * {@hide}
      */
+    public String[] getTetherableEthernetRegexs() {
+        try {
+            return mService.getTetherableEthernetRegexs();
+        } catch (RemoteException e) {
+            return new String[0];
+        }
+    }
+
+    /**
+     * {@hide}
+     */
     public String[] getTetherableBluetoothRegexs() {
         try {
             return mService.getTetherableBluetoothRegexs();
diff --git a/core/java/android/net/EthernetDataTracker.java b/core/java/android/net/EthernetDataTracker.java
index 3a06dc0..f7fef1b 100644
--- a/core/java/android/net/EthernetDataTracker.java
+++ b/core/java/android/net/EthernetDataTracker.java
@@ -402,7 +402,7 @@ public class EthernetDataTracker implements NetworkStateTracker {
      * for this network.
      */
     public String getTcpBufferSizesPropName() {
-        return "net.tcp.buffersize.wifi";
+        return "net.tcp.buffersize.ethernet";
     }
 
     public void setDependencyMet(boolean met) {
diff --git a/core/java/android/net/NetworkUtils.java b/core/java/android/net/NetworkUtils.java
index d39e741..cc42e3a 100644
--- a/core/java/android/net/NetworkUtils.java
+++ b/core/java/android/net/NetworkUtils.java
@@ -103,6 +103,33 @@ public class NetworkUtils {
     public native static String getDhcpError();
 
     /**
+     * Statically configure a network interface.
+     * @param interfaceName the name of the interface to configure
+     * @param ipInfo the network interface settings to be configured.
+     * @return {@code true} for success, {@code false} for failure
+     */
+    public static boolean configureInterface(String interfaceName, DhcpInfo ipInfo) {
+        return configureNative(interfaceName,
+			       ipInfo.ipAddress,
+			       netmaskIntToPrefixLength(ipInfo.netmask),
+			       ipInfo.gateway,
+			       ipInfo.dns1,
+			       ipInfo.dns2);
+    }
+
+    /**
+     * Statically configure a network interface.
+     * @param interfaceName the name of the interface to configure
+     * @param ipAddress the IP address to configure the interface with
+     * @param prefixLength the length of IP prefix
+     * @param gateway the IP address of the gateway
+     * @param dns1 the IP address of first DNS server
+     * @param dns2 the IP address of second DNS server
+     * @return {@code true} for success, {@code false} for failure
+     */
+    private native static boolean configureNative(String interfaceName, int ipAddress, int prefixLength, int gateway, int dns1, int dns2);
+
+    /**
      * Convert a IPv4 address from an integer to an InetAddress.
      * @param hostAddress an int corresponding to the IPv4 address in network byte order
      */
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index b94f0b9..7dd86df 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -4862,6 +4862,18 @@ public final class Settings {
        public static final String WIFI_P2P_DEVICE_NAME = "wifi_p2p_device_name";
 
        /**
+        * 
+        */
+       public static final String ETHERNET_ON      = "ethernet_on";
+       public static final String ETHERNET_MODE    = "ethernet_mode";
+       public static final String ETHERNET_IP      = "ethernet_ip";
+       public static final String ETHERNET_MASK    = "ethernet_netmask";
+       public static final String ETHERNET_DNS     = "ethernet_dns";
+       public static final String ETHERNET_ROUTE   = "ethernet_iproute";
+       public static final String ETHERNET_CONF    = "ethernet_conf";
+       public static final String ETHERNET_IFNAME  = "ethernet_ifname";
+
+       /**
         * The number of milliseconds to delay when checking for data stalls during
         * non-aggressive detection. (screen is turned off.)
         * @hide
diff --git a/core/java/com/android/internal/util/Protocol.java b/core/java/com/android/internal/util/Protocol.java
index 7c2b1b5..d790ebe 100644
--- a/core/java/com/android/internal/util/Protocol.java
+++ b/core/java/com/android/internal/util/Protocol.java
@@ -51,5 +51,8 @@ public class Protocol {
     public static final int BASE_DATA_CONNECTION_TRACKER                            = 0x00042000;
     public static final int BASE_DNS_PINGER                                         = 0x00050000;
     public static final int BASE_NSD_MANAGER                                        = 0x00060000;
+    public static final int BASE_ETHERNET                                           = 0x00070000;
+    public static final int BASE_ETHERNET_MONITOR                                   = 0x00071000;
+    public static final int BASE_ETHERNET_MANAGER                                   = 0x00072000;
     //TODO: define all used protocols
 }
diff --git a/core/jni/Android.mk b/core/jni/Android.mk
index 3ca085b..d6c9b7c 100644
--- a/core/jni/Android.mk
+++ b/core/jni/Android.mk
@@ -76,6 +76,7 @@ LOCAL_SRC_FILES:= \
 	android_net_NetUtils.cpp \
 	android_net_TrafficStats.cpp \
 	android_net_wifi_Wifi.cpp \
+	android_net_ethernet_Ethernet.cpp \
 	android_nio_utils.cpp \
 	android_text_format_Time.cpp \
 	android_util_AssetManager.cpp \
diff --git a/core/jni/AndroidRuntime.cpp b/core/jni/AndroidRuntime.cpp
index 9820e60..6bac598 100644
--- a/core/jni/AndroidRuntime.cpp
+++ b/core/jni/AndroidRuntime.cpp
@@ -146,6 +146,7 @@ extern int register_android_net_LocalSocketImpl(JNIEnv* env);
 extern int register_android_net_NetworkUtils(JNIEnv* env);
 extern int register_android_net_TrafficStats(JNIEnv* env);
 extern int register_android_net_wifi_WifiManager(JNIEnv* env);
+extern int register_android_net_ethernet_EthernetManager(JNIEnv* env);
 extern int register_android_text_AndroidCharacter(JNIEnv *env);
 extern int register_android_text_AndroidBidi(JNIEnv *env);
 extern int register_android_opengl_classes(JNIEnv *env);
@@ -1174,6 +1175,7 @@ static const RegJNIRec gRegJNI[] = {
     REG_JNI(register_android_net_NetworkUtils),
     REG_JNI(register_android_net_TrafficStats),
     REG_JNI(register_android_net_wifi_WifiManager),
+    REG_JNI(register_android_net_ethernet_EthernetManager),
     REG_JNI(register_android_os_MemoryFile),
     REG_JNI(register_com_android_internal_os_ZygoteInit),
     REG_JNI(register_android_hardware_Camera),
diff --git a/core/jni/android_net_NetUtils.cpp b/core/jni/android_net_NetUtils.cpp
index 1f2b1ae..8dec46e 100644
--- a/core/jni/android_net_NetUtils.cpp
+++ b/core/jni/android_net_NetUtils.cpp
@@ -27,6 +27,9 @@ extern "C" {
 int ifc_enable(const char *ifname);
 int ifc_disable(const char *ifname);
 int ifc_reset_connections(const char *ifname, int reset_mask);
+int ifc_configure(const char *ifname, in_addr_t ipaddr, uint32_t prefixLength, in_addr_t gateway, in_addr_t dns1, in_addr_t dns2);
+int ifc_remove_default_route(const char *ifname);
+
 
 int dhcp_do_request(const char *ifname,
                     const char *ipaddr,
@@ -108,6 +111,27 @@ static jint android_net_utils_resetConnections(JNIEnv* env, jobject clazz,
     return (jint)result;
 }
 
+static jboolean android_net_utils_configureInterface(JNIEnv* env, jobject clazz, jstring ifname, jint ipaddr, jint prefixLength, jint gateway, jint dns1, jint dns2)
+{
+    int result;
+    uint32_t lease;
+
+    const char *nameStr = env->GetStringUTFChars(ifname, NULL);
+    result = ifc_configure(nameStr, ipaddr, prefixLength, gateway, dns1, dns2);
+    env->ReleaseStringUTFChars(ifname, nameStr);
+    return (jboolean)(result == 0);
+}
+
+static jint android_net_utils_removeDefaultRoute(JNIEnv* env, jobject clazz, jstring ifname)
+{
+    int result;
+
+    const char *nameStr = env->GetStringUTFChars(ifname, NULL);
+    result = ::ifc_remove_default_route(nameStr);
+    env->ReleaseStringUTFChars(ifname, nameStr);
+    return (jint)result;
+}
+
 static jboolean android_net_utils_runDhcpCommon(JNIEnv* env, jobject clazz, jstring ifname,
         jobject info, bool renew)
 {
@@ -222,6 +246,7 @@ static JNINativeMethod gNetworkUtilMethods[] = {
     { "stopDhcp", "(Ljava/lang/String;)Z",  (void *)android_net_utils_stopDhcp },
     { "releaseDhcpLease", "(Ljava/lang/String;)Z",  (void *)android_net_utils_releaseDhcpLease },
     { "getDhcpError", "()Ljava/lang/String;", (void*) android_net_utils_getDhcpError },
+    { "configureNative", "(Ljava/lang/String;IIIII)Z", (void *)android_net_utils_configureInterface },
 };
 
 int register_android_net_NetworkUtils(JNIEnv* env)
diff --git a/core/jni/android_net_ethernet_Ethernet.cpp b/core/jni/android_net_ethernet_Ethernet.cpp
new file mode 100644
index 0000000..269a192
--- /dev/null
+++ b/core/jni/android_net_ethernet_Ethernet.cpp
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "ethernet"
+
+#include "jni.h"
+#include <ScopedUtfChars.h>
+#include <utils/misc.h>
+#include <android_runtime/AndroidRuntime.h>
+#include <utils/Log.h>
+#include <utils/String16.h>
+#include <utils/Endian.h>
+
+#include <linux/if_ether.h>
+
+#include "ethernet.h"
+
+#define ETHERNET_PKG_NAME     "android/net/ethernet/EthernetNative"
+#define EVENT_BUF_SIZE 2048
+
+namespace android {
+
+static jint DBG = false;
+
+static jboolean android_net_ethernet_isDriverLoaded(JNIEnv* env, jobject)
+{
+    return (jboolean)(::is_ethernet_driver_loaded() == 1);
+}
+
+static jboolean android_net_ethernet_loadDriver(JNIEnv* env, jobject)
+{
+    return (jboolean)(::ethernet_load_driver() == 0);
+}
+
+static jboolean android_net_ethernet_unloadDriver(JNIEnv* env, jobject)
+{
+    return (jboolean)(::ethernet_unload_driver() == 0);
+}
+
+static jstring android_net_ethernet_getMacAddress(JNIEnv *env, jobject, jstring jIface)
+{
+    ScopedUtfChars ifname(env, jIface);
+    unsigned char *ptr;
+    uint8_t addr[ETH_ALEN];
+    char buf[20];
+    int n;
+
+    n = ::ethernet_get_hwaddr(ifname.c_str(), addr);
+    if (n == -1)
+        return NULL;
+
+    ptr = (unsigned char *) addr;
+
+    memset (buf, '\0', sizeof(buf));
+#ifdef HAVE_LITTLE_ENDIAN
+    sprintf (buf, "%02x:%02x:%02x:%02x:%02x:%02x",
+	     (ptr[0] & 0xFF), (ptr[1] & 0xFF), (ptr[2] & 0xFF),
+	     (ptr[3] & 0xFF), (ptr[4] & 0xFF), (ptr[5] & 0xFF));
+#else
+    sprintf (buf, "%02x:%02x:%02x:%02x:%02x:%02x",
+	     (ptr[5] & 0xFF), (ptr[4] & 0xFF), (ptr[3] & 0xFF),
+	     (ptr[2] & 0xFF), (ptr[1] & 0xFF), (ptr[0] & 0xFF));
+#endif
+
+    ALOGI("MAC Address: %s\n", buf);
+
+    return env->NewStringUTF(buf);
+}
+
+static jboolean android_net_ethernet_initEventChannel(JNIEnv* env, jobject)
+{
+    return (jboolean)(::ethernet_init_event() == 0);
+}
+
+static jboolean android_net_ethernet_shutdownEventChannel(JNIEnv* env, jobject)
+{
+    return (jboolean)(::ethernet_shutdown_event() == 0);
+}
+
+static jstring android_net_ethernet_waitForEvent(JNIEnv* env, jobject, jstring jIface)
+{
+    char buf[EVENT_BUF_SIZE];
+    ScopedUtfChars ifname(env, jIface);
+    int nread = ::ethernet_wait_for_event(ifname.c_str(), buf, sizeof buf);
+    if (nread > 0) {
+        return env->NewStringUTF(buf);
+    } else {
+        return NULL;
+    }
+}
+
+// ----------------------------------------------------------------------------
+
+/*
+ * JNI registration.
+ */
+static JNINativeMethod gEthernetMethods[] = {
+
+    /* name, signature, funcPtr */
+    { "loadDriver", "()Z",  (void *)android_net_ethernet_loadDriver },
+    { "isDriverLoaded", "()Z",  (void *)android_net_ethernet_isDriverLoaded },
+    { "unloadDriver", "()Z",  (void *)android_net_ethernet_unloadDriver },
+    { "getMacAddress", "(Ljava/lang/String;)Ljava/lang/String;",  (void *)android_net_ethernet_getMacAddress},
+    { "initEvent", "()Z",  (void *)android_net_ethernet_initEventChannel },
+    { "shutdownEvent", "()Z",  (void *)android_net_ethernet_shutdownEventChannel },
+    { "waitForEvent", "(Ljava/lang/String;)Ljava/lang/String;",  (void*) android_net_ethernet_waitForEvent },
+
+
+};
+
+int register_android_net_ethernet_EthernetManager(JNIEnv* env)
+{
+    return AndroidRuntime::registerNativeMethods(env,
+            ETHERNET_PKG_NAME, gEthernetMethods, NELEM(gEthernetMethods));
+}
+
+}; // namespace android
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 3b7d73a..9bd7c9d 100755
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -34,6 +34,7 @@
        <item><xliff:g id="id">mute</xliff:g></item>
        <item><xliff:g id="id">volume</xliff:g></item>
        <item><xliff:g id="id">wifi</xliff:g></item>
+       <item><xliff:g id="id">ethernet</xliff:g></item>
        <item><xliff:g id="id">cdma_eri</xliff:g></item>
        <item><xliff:g id="id">data_connection</xliff:g></item>
        <item><xliff:g id="id">phone_evdo_signal</xliff:g></item>
@@ -145,6 +146,7 @@
         <item>"mobile_mms,2,0,2,60000,true"</item>
         <item>"mobile_supl,3,0,2,60000,true"</item>
         <item>"mobile_hipri,5,0,3,60000,true"</item>
+        <item>"ethernet,9,0,1,-1,true"</item>
         <item>"mobile_fota,10,0,2,60000,true"</item>
         <item>"mobile_ims,11,0,2,60000,true"</item>
         <item>"mobile_cbs,12,0,2,60000,true"</item>
@@ -165,6 +167,7 @@
     <!-- An Array of "[ConnectivityManager connectionType],
                       [# simultaneous connection types]"  -->
     <string-array translatable="false" name="radioAttributes">
+        <item>"9,1"</item>
         <item>"1,1"</item>
         <item>"0,1"</item>
     </string-array>
@@ -197,6 +200,12 @@
     </string-array>
 
     <!-- List of regexpressions describing the interface (if any) that represent tetherable
+         Ethernet interfaces.  If the device doesn't want to support tethering over Ethernet this
+         should be empty.  An example would be "ethernet.*" -->
+    <string-array translatable="false" name="config_tether_ethernet_regexs">
+    </string-array>
+
+    <!-- List of regexpressions describing the interface (if any) that represent tetherable
          WiMAX interfaces.  If the device doesn't want to support tethering over Wifi this
          should be empty.  An example would be "softap.*" -->
     <string-array translatable="false" name="config_tether_wimax_regexs">
@@ -713,6 +722,9 @@
     <!-- Enables SIP on WIFI only -->
     <bool name="config_sip_wifi_only">false</bool>
 
+    <!-- Enables SIP on Ethernet only -->
+    <bool name="config_sip_ethernet_only">false</bool>
+
     <!-- Enables built-in SIP phone capability -->
     <bool name="config_built_in_sip_phone">true</bool>
 
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 68a0289..97819e0 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -254,6 +254,7 @@
   <java-symbol type="bool" name="config_mms_content_disposition_support" />
   <java-symbol type="bool" name="config_showMenuShortcutsWhenKeyboardPresent" />
   <java-symbol type="bool" name="config_sip_wifi_only" />
+  <java-symbol type="bool" name="config_sip_ethernet_only" />
   <java-symbol type="bool" name="config_sms_capable" />
   <java-symbol type="bool" name="config_sms_utf8_support" />
   <java-symbol type="bool" name="config_swipeDisambiguation" />
diff --git a/data/etc/platform.xml b/data/etc/platform.xml
index 13d1791..70798f2 100644
--- a/data/etc/platform.xml
+++ b/data/etc/platform.xml
@@ -133,6 +133,7 @@
     <assign-permission name="android.permission.ACCESS_LOCATION_EXTRA_COMMANDS" uid="shell" />
     <assign-permission name="android.permission.ACCESS_NETWORK_STATE" uid="shell" />
     <assign-permission name="android.permission.ACCESS_WIFI_STATE" uid="shell" />
+    <assign-permission name="android.permission.ACCESS_ETHERNET_STATE" uid="shell" />
     <assign-permission name="android.permission.BLUETOOTH" uid="shell" />
     <!-- System tool permissions granted to the shell. -->
     <assign-permission name="android.permission.GET_TASKS" uid="shell" />
diff --git a/docs/html/guide/topics/manifest/uses-feature-element.jd b/docs/html/guide/topics/manifest/uses-feature-element.jd
index 10b5a33..c56d45a 100644
--- a/docs/html/guide/topics/manifest/uses-feature-element.jd
+++ b/docs/html/guide/topics/manifest/uses-feature-element.jd
@@ -839,6 +839,13 @@ hosts).</td>
   <td></td>
 </tr>
 
+<tr>
+  <td>Ethernet</td>
+  <td><code>android.hardware.ethernet</code></td>
+  <td>The application uses 802.3 networking (Ethernet) features on the device.</td>
+  <td></td>
+</tr>
+
   </table>
 
 <h3 id="sw-features">Software features</h3>
diff --git a/ethernet/java/android/net/ethernet/EthernetConfigStore.java b/ethernet/java/android/net/ethernet/EthernetConfigStore.java
new file mode 100644
index 0000000..1eaa607
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/EthernetConfigStore.java
@@ -0,0 +1,1147 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.ethernet;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.DhcpInfoInternal;
+import android.net.LinkAddress;
+import android.net.LinkProperties;
+import android.net.NetworkUtils;
+import android.net.NetworkInfo.DetailedState;
+import android.net.ProxyProperties;
+import android.net.RouteInfo;
+import android.net.ethernet.EthernetConfiguration.IpAssignment;
+import android.net.ethernet.EthernetConfiguration.ProxySettings;
+import android.net.ethernet.NetworkUpdateResult;
+import static android.net.ethernet.EthernetConfiguration.INVALID_NETWORK_ID;
+import android.os.Environment;
+import android.os.Message;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.UserHandle;
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.EOFException;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * This class provides the API to manage configured
+ * ethernet networks. The API is not thread safe is being
+ * used only from EthernetStateMachine.
+ *
+ * It deals with the following
+ * - Add/update/remove a EthernetConfiguration
+ *   The configuration contains the following type of information.
+ *     = IP and proxy configuration that is handled by EthernetConfigStore and
+ *       is saved to disk on any change.
+ *
+ *       The format of configuration file is as follows:
+ *       <version>
+ *       <netA_key1><netA_value1><netA_key2><netA_value2>...<EOS>
+ *       <netB_key1><netB_value1><netB_key2><netB_value2>...<EOS>
+ *       ..
+ *
+ *       (key, value) pairs for a given network are grouped together and can
+ *       be in any order. A EOS at the end of a set of (key, value) pairs
+ *       indicates that the next set of (key, value) pairs are for a new
+ *       network. A network is identified by a unique ID_KEY. If there is no
+ *       ID_KEY in the (key, value) pairs, the data is discarded.
+ *
+ *       An invalid version on read would result in discarding the contents of
+ *       the file. On the next write, the latest version is written to file.
+ *
+ *       Any failures during read or write to the configuration file are ignored
+ *       without reporting to the user since the likelihood of these errors are
+ *       low and the impact on connectivity is low.
+ *
+ *       We have two kinds of APIs exposed:
+ *        > public API calls that provide fine grained control
+ *          - enableNetwork, disableNetwork, addOrUpdateNetwork(),
+ *          removeNetwork(). For these calls, the config is not persisted
+ *          to the disk. (TODO: deprecate these calls in EthernetManager)
+ *        > The new API calls - selectNetwork(), saveNetwork() & forgetNetwork().
+ *          These calls persist the supplicant config to disk.
+ *
+ * - Maintain a list of configured networks for quick access
+ *
+ */
+class EthernetConfigStore {
+
+    private Context mContext;
+    private static final String TAG = "EthernetConfigStore";
+    private static final boolean DBG = false;
+
+    /* configured networks with network id as the key */
+    private HashMap<Integer, EthernetConfiguration> mConfiguredNetworks =
+            new HashMap<Integer, EthernetConfiguration>();
+
+    /* A network id is a unique identifier for a configured network.
+     * We store the IP configuration for networks along with a unique id
+     * that is generated from network name.
+     */
+    private HashMap<Integer, Integer> mNetworkIds =
+            new HashMap<Integer, Integer>();
+
+    /* Tracks the highest priority of configured networks */
+    private int mLastPriority = -1;
+
+    private static final String ipConfigFile = Environment.getDataDirectory() +
+            "/misc/ethernet/ipconfig.txt";
+
+    private static final int IPCONFIG_FILE_VERSION = 2;
+
+    /* IP and proxy configuration keys */
+    private static final String ID_KEY = "id";
+    private static final String IP_ASSIGNMENT_KEY = "ipAssignment";
+    private static final String LINK_ADDRESS_KEY = "linkAddress";
+    private static final String GATEWAY_KEY = "gateway";
+    private static final String DNS_KEY = "dns";
+    private static final String PROXY_SETTINGS_KEY = "proxySettings";
+    private static final String PROXY_HOST_KEY = "proxyHost";
+    private static final String PROXY_PORT_KEY = "proxyPort";
+    private static final String EXCLUSION_LIST_KEY = "exclusionList";
+    private static final String EOS = "eos";
+
+    private EthernetNative mEthernetNative;
+
+    EthernetConfigStore(Context c, EthernetNative wn) {
+        mContext = c;
+        mEthernetNative = wn;
+    }
+
+    /**
+     * Fetch the list of configured networks
+     * and enable all stored networks in supplicant.
+     */
+    void initialize() {
+        if (DBG) log("Loading config and enabling all networks");
+        loadConfiguredNetworks();
+        enableAllNetworks();
+    }
+
+    /**
+     * Fetch the list of currently configured networks
+     * @return List of networks
+     */
+    List<EthernetConfiguration> getConfiguredNetworks() {
+        List<EthernetConfiguration> networks = new ArrayList<EthernetConfiguration>();
+        for(EthernetConfiguration config : mConfiguredNetworks.values()) {
+            networks.add(new EthernetConfiguration(config));
+        }
+        return networks;
+    }
+
+    /**
+     * enable all networks and save config. This will be a no-op if the list
+     * of configured networks indicates all networks as being enabled
+     */
+    void enableAllNetworks() {
+        boolean networkEnabledStateChanged = false;
+        for(EthernetConfiguration config : mConfiguredNetworks.values()) {
+            if(config != null && config.status == Status.DISABLED) {
+                if(mEthernetNative.enableNetwork(config.networkId, false)) {
+                    networkEnabledStateChanged = true;
+                    config.status = Status.ENABLED;
+                } else {
+                    loge("Enable network failed on " + config.networkId);
+                }
+            }
+        }
+
+        if (networkEnabledStateChanged) {
+            mEthernetNative.saveConfig();
+            sendConfiguredNetworksChangedBroadcast();
+        }
+    }
+
+
+    /**
+     * Selects the specified network for connection. This involves
+     * updating the priority of all the networks and enabling the given
+     * network while disabling others.
+     *
+     * Selecting a network will leave the other networks disabled and
+     * a call to enableAllNetworks() needs to be issued upon a connection
+     * or a failure event from supplicant
+     *
+     * @param netId network to select for connection
+     * @return false if the network id is invalid
+     */
+    boolean selectNetwork(int netId) {
+        if (netId == INVALID_NETWORK_ID) return false;
+
+        // Reset the priority of each network at start or if it goes too high.
+        if (mLastPriority == -1 || mLastPriority > 1000000) {
+            for(EthernetConfiguration config : mConfiguredNetworks.values()) {
+                if (config.networkId != INVALID_NETWORK_ID) {
+                    config.priority = 0;
+                    addOrUpdateNetworkNative(config);
+                }
+            }
+            mLastPriority = 0;
+        }
+
+        // Set to the highest priority and save the configuration.
+        EthernetConfiguration config = new EthernetConfiguration();
+        config.networkId = netId;
+        config.priority = ++mLastPriority;
+
+        addOrUpdateNetworkNative(config);
+        mEthernetNative.saveConfig();
+
+        /* Enable the given network while disabling all other networks */
+        enableNetworkWithoutBroadcast(netId, true);
+
+       /* Avoid saving the config & sending a broadcast to prevent settings
+        * from displaying a disabled list of networks */
+        return true;
+    }
+
+    /**
+     * Add/update the specified configuration and save config
+     *
+     * @param config EthernetConfiguration to be saved
+     * @return network update result
+     */
+    NetworkUpdateResult saveNetwork(EthernetConfiguration config) {
+        // A new network cannot have null name
+        if (config == null || (config.networkId == INVALID_NETWORK_ID &&
+                config.networkName == null)) {
+            return new NetworkUpdateResult(INVALID_NETWORK_ID);
+        }
+
+        boolean newNetwork = (config.networkId == INVALID_NETWORK_ID);
+        NetworkUpdateResult result = addOrUpdateNetworkNative(config);
+        int netId = result.getNetworkId();
+        /* enable a new network */
+        if (newNetwork && netId != INVALID_NETWORK_ID) {
+            mEthernetNative.enableNetwork(netId, false);
+            mConfiguredNetworks.get(netId).status = Status.ENABLED;
+        }
+        mEthernetNative.saveConfig();
+        sendConfiguredNetworksChangedBroadcast(config, result.isNewNetwork() ?
+                EthernetManager.CHANGE_REASON_ADDED : EthernetManager.CHANGE_REASON_CONFIG_CHANGE);
+        return result;
+    }
+
+    void updateStatus(int netId, DetailedState state) {
+        if (netId != INVALID_NETWORK_ID) {
+            EthernetConfiguration config = mConfiguredNetworks.get(netId);
+            if (config == null) return;
+            switch (state) {
+                case CONNECTED:
+                    config.status = Status.CURRENT;
+                    break;
+                case DISCONNECTED:
+                    //If network is already disabled, keep the status
+                    if (config.status == Status.CURRENT) {
+                        config.status = Status.ENABLED;
+                    }
+                    break;
+                default:
+                    //do nothing, retain the existing state
+                    break;
+            }
+        }
+    }
+
+    /**
+     * Forget the specified network and save config
+     *
+     * @param netId network to forget
+     * @return {@code true} if it succeeds, {@code false} otherwise
+     */
+    boolean forgetNetwork(int netId) {
+        if (mEthernetNative.removeNetwork(netId)) {
+            mEthernetNative.saveConfig();
+            EthernetConfiguration target = null;
+            EthernetConfiguration config = mConfiguredNetworks.get(netId);
+            if (config != null) {
+                target = mConfiguredNetworks.remove(netId);
+                mNetworkIds.remove(configKey(config));
+            }
+            if (target != null) {
+                writeIpAndProxyConfigurations();
+                sendConfiguredNetworksChangedBroadcast(target, EthernetManager.CHANGE_REASON_REMOVED);
+            }
+            return true;
+        } else {
+            loge("Failed to remove network " + netId);
+            return false;
+        }
+    }
+
+    /**
+     * Add/update a network. Note that there is no saveConfig operation.
+     * This function is retained for compatibility with the public
+     * API. The more powerful saveNetwork() is used by the
+     * state machine
+     *
+     * @param config ethernet configuration to add/update
+     * @return network Id
+     */
+    int addOrUpdateNetwork(EthernetConfiguration config) {
+        NetworkUpdateResult result = addOrUpdateNetworkNative(config);
+        if (result.getNetworkId() != EthernetConfiguration.INVALID_NETWORK_ID) {
+            sendConfiguredNetworksChangedBroadcast(mConfiguredNetworks.get(result.getNetworkId()),
+                    result.isNewNetwork ? EthernetManager.CHANGE_REASON_ADDED :
+                        EthernetManager.CHANGE_REASON_CONFIG_CHANGE);
+        }
+        return result.getNetworkId();
+    }
+
+    /**
+     * Remove a network. Note that there is no saveConfig operation.
+     * This function is retained for compatibility with the public
+     * API. The more powerful forgetNetwork() is used by the
+     * state machine for network removal
+     *
+     * @param netId network to be removed
+     * @return {@code true} if it succeeds, {@code false} otherwise
+     */
+    boolean removeNetwork(int netId) {
+        boolean ret = mEthernetNative.removeNetwork(netId);
+        EthernetConfiguration config = null;
+        if (ret) {
+            config = mConfiguredNetworks.get(netId);
+            if (config != null) {
+                config = mConfiguredNetworks.remove(netId);
+                mNetworkIds.remove(configKey(config));
+            }
+        }
+        if (config != null) {
+            sendConfiguredNetworksChangedBroadcast(config, EthernetManager.CHANGE_REASON_REMOVED);
+        }
+        return ret;
+    }
+
+    /**
+     * Enable a network. Note that there is no saveConfig operation.
+     * This function is retained for compatibility with the public
+     * API. The more powerful selectNetwork()/saveNetwork() is used by the
+     * state machine for connecting to a network
+     *
+     * @param netId network to be enabled
+     * @return {@code true} if it succeeds, {@code false} otherwise
+     */
+    boolean enableNetwork(int netId, boolean disableOthers) {
+        boolean ret = enableNetworkWithoutBroadcast(netId, disableOthers);
+        if (disableOthers) {
+            sendConfiguredNetworksChangedBroadcast();
+        } else {
+            EthernetConfiguration enabledNetwork = null;
+            synchronized(mConfiguredNetworks) {
+                enabledNetwork = mConfiguredNetworks.get(netId);
+            }
+            // check just in case the network was removed by someone else.
+            if (enabledNetwork != null) {
+                sendConfiguredNetworksChangedBroadcast(enabledNetwork,
+                        EthernetManager.CHANGE_REASON_CONFIG_CHANGE);
+            }
+        }
+        return ret;
+    }
+
+    boolean enableNetworkWithoutBroadcast(int netId, boolean disableOthers) {
+        boolean ret = mEthernetNative.enableNetwork(netId, disableOthers);
+
+        EthernetConfiguration config = mConfiguredNetworks.get(netId);
+        if (config != null) config.status = Status.ENABLED;
+
+        if (disableOthers) {
+            markAllNetworksDisabledExcept(netId);
+        }
+        return ret;
+    }
+
+    /**
+     * Disable a network. Note that there is no saveConfig operation.
+     * @param netId network to be disabled
+     * @return {@code true} if it succeeds, {@code false} otherwise
+     */
+    boolean disableNetwork(int netId) {
+        return disableNetwork(netId, EthernetConfiguration.DISABLED_UNKNOWN_REASON);
+    }
+
+    /**
+     * Disable a network. Note that there is no saveConfig operation.
+     * @param netId network to be disabled
+     * @param reason reason code network was disabled
+     * @return {@code true} if it succeeds, {@code false} otherwise
+     */
+    boolean disableNetwork(int netId, int reason) {
+        boolean ret = mEthernetNative.disableNetwork(netId);
+        EthernetConfiguration network = null;
+        EthernetConfiguration config = mConfiguredNetworks.get(netId);
+        /* Only change the reason if the network was not previously disabled */
+        if (config != null && config.status != Status.DISABLED) {
+            config.status = Status.DISABLED;
+            config.disableReason = reason;
+            network = config;
+        }
+        if (network != null) {
+            sendConfiguredNetworksChangedBroadcast(network,
+                    EthernetManager.CHANGE_REASON_CONFIG_CHANGE);
+        }
+        return ret;
+    }
+
+    /**
+     * Save the configured networks in supplicant to disk
+     * @return {@code true} if it succeeds, {@code false} otherwise
+     */
+    boolean saveConfig() {
+        return mEthernetNative.saveConfig();
+    }
+
+    /**
+     * Fetch the link properties for a given network id
+     * @return LinkProperties for the given network id
+     */
+    LinkProperties getLinkProperties(int netId) {
+        EthernetConfiguration config = mConfiguredNetworks.get(netId);
+        if (config != null) return new LinkProperties(config.linkProperties);
+        return null;
+    }
+
+    /**
+     * get IP configuration for a given network id
+     * TODO: We cannot handle IPv6 addresses for configuration
+     *       right now until NetworkUtils is fixed. When we do
+     *       that, we should remove handling DhcpInfo and move
+     *       to using LinkProperties
+     * @return DhcpInfoInternal for the given network id
+     */
+    DhcpInfoInternal getIpConfiguration(int netId) {
+        DhcpInfoInternal dhcpInfoInternal = new DhcpInfoInternal();
+        LinkProperties linkProperties = getLinkProperties(netId);
+
+        if (linkProperties != null) {
+            Iterator<LinkAddress> iter = linkProperties.getLinkAddresses().iterator();
+            if (iter.hasNext()) {
+                LinkAddress linkAddress = iter.next();
+                dhcpInfoInternal.ipAddress = linkAddress.getAddress().getHostAddress();
+                for (RouteInfo route : linkProperties.getRoutes()) {
+                    dhcpInfoInternal.addRoute(route);
+                }
+                dhcpInfoInternal.prefixLength = linkAddress.getNetworkPrefixLength();
+                Iterator<InetAddress> dnsIterator = linkProperties.getDnses().iterator();
+                dhcpInfoInternal.dns1 = dnsIterator.next().getHostAddress();
+                if (dnsIterator.hasNext()) {
+                    dhcpInfoInternal.dns2 = dnsIterator.next().getHostAddress();
+                }
+            }
+        }
+        return dhcpInfoInternal;
+    }
+
+    /**
+     * set IP configuration for a given network id
+     */
+    void setIpConfiguration(int netId, DhcpInfoInternal dhcpInfo) {
+        LinkProperties linkProperties = dhcpInfo.makeLinkProperties();
+
+        EthernetConfiguration config = mConfiguredNetworks.get(netId);
+        if (config != null) {
+            // add old proxy details
+            if(config.linkProperties != null) {
+                linkProperties.setHttpProxy(config.linkProperties.getHttpProxy());
+            }
+            config.linkProperties = linkProperties;
+        }
+    }
+
+    /**
+     * clear IP configuration for a given network id
+     * @param network id
+     */
+    void clearIpConfiguration(int netId) {
+        EthernetConfiguration config = mConfiguredNetworks.get(netId);
+        if (config != null && config.linkProperties != null) {
+            // Clear everything except proxy
+            ProxyProperties proxy = config.linkProperties.getHttpProxy();
+            config.linkProperties.clear();
+            config.linkProperties.setHttpProxy(proxy);
+        }
+    }
+
+    /**
+     * Fetch the proxy properties for a given network id
+     * @param network id
+     * @return ProxyProperties for the network id
+     */
+    ProxyProperties getProxyProperties(int netId) {
+        LinkProperties linkProperties = getLinkProperties(netId);
+        if (linkProperties != null) {
+            return new ProxyProperties(linkProperties.getHttpProxy());
+        }
+        return null;
+    }
+
+    /**
+     * Return if the specified network is using static IP
+     * @param network id
+     * @return {@code true} if using static ip for netId
+     */
+    boolean isUsingStaticIp(int netId) {
+        EthernetConfiguration config = mConfiguredNetworks.get(netId);
+        if (config != null && config.ipAssignment == IpAssignment.STATIC) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Should be called when a single network configuration is made.
+     * @param network The network configuration that changed.
+     * @param reason The reason for the change, should be one of EthernetManager.CHANGE_REASON_ADDED,
+     * EthernetManager.CHANGE_REASON_REMOVED, or EthernetManager.CHANGE_REASON_CHANGE.
+     */
+    private void sendConfiguredNetworksChangedBroadcast(EthernetConfiguration network,
+            int reason) {
+        Intent intent = new Intent(EthernetManager.CONFIGURED_NETWORKS_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(EthernetManager.EXTRA_MULTIPLE_NETWORKS_CHANGED, false);
+        intent.putExtra(EthernetManager.EXTRA_ETHERNET_CONFIGURATION, network);
+        intent.putExtra(EthernetManager.EXTRA_CHANGE_REASON, reason);
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    /**
+     * Should be called when multiple network configuration changes are made.
+     */
+    private void sendConfiguredNetworksChangedBroadcast() {
+        Intent intent = new Intent(EthernetManager.CONFIGURED_NETWORKS_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(EthernetManager.EXTRA_MULTIPLE_NETWORKS_CHANGED, true);
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    void loadConfiguredNetworks() {
+        String listStr = mEthernetNative.listNetworks();
+        mLastPriority = 0;
+
+        mConfiguredNetworks.clear();
+        mNetworkIds.clear();
+
+        if (listStr == null)
+            return;
+
+        String[] lines = listStr.split("\n");
+        // Skip the first line, which is a header
+        for (int i = 1; i < lines.length; i++) {
+            String[] result = lines[i].split("\t");
+            // network-id | ssid | bssid | flags
+            EthernetConfiguration config = new EthernetConfiguration();
+            try {
+                config.networkId = Integer.parseInt(result[0]);
+            } catch(NumberFormatException e) {
+                continue;
+            }
+            if (result.length > 3) {
+                if (result[3].indexOf("[CURRENT]") != -1)
+                    config.status = EthernetConfiguration.Status.CURRENT;
+                else if (result[3].indexOf("[DISABLED]") != -1)
+                    config.status = EthernetConfiguration.Status.DISABLED;
+                else
+                    config.status = EthernetConfiguration.Status.ENABLED;
+            } else {
+                config.status = EthernetConfiguration.Status.ENABLED;
+            }
+            readNetworkVariables(config);
+            if (config.priority > mLastPriority) {
+                mLastPriority = config.priority;
+            }
+            mConfiguredNetworks.put(config.networkId, config);
+            mNetworkIds.put(configKey(config), config.networkId);
+        }
+
+        readIpAndProxyConfigurations();
+        sendConfiguredNetworksChangedBroadcast();
+    }
+
+    /* Mark all networks except specified netId as disabled */
+    private void markAllNetworksDisabledExcept(int netId) {
+        for(EthernetConfiguration config : mConfiguredNetworks.values()) {
+            if(config != null && config.networkId != netId) {
+                if (config.status != Status.DISABLED) {
+                    config.status = Status.DISABLED;
+                    config.disableReason = EthernetConfiguration.DISABLED_UNKNOWN_REASON;
+                }
+            }
+        }
+    }
+
+    private void markAllNetworksDisabled() {
+        markAllNetworksDisabledExcept(INVALID_NETWORK_ID);
+    }
+
+    private void writeIpAndProxyConfigurations() {
+
+        /* Make a copy */
+        List<EthernetConfiguration> networks = new ArrayList<EthernetConfiguration>();
+        for(EthernetConfiguration config : mConfiguredNetworks.values()) {
+            networks.add(new EthernetConfiguration(config));
+        }
+
+        DelayedDiskWrite.write(networks);
+    }
+
+    private static class DelayedDiskWrite {
+
+        private static HandlerThread sDiskWriteHandlerThread;
+        private static Handler sDiskWriteHandler;
+        /* Tracks multiple writes on the same thread */
+        private static int sWriteSequence = 0;
+        private static final String TAG = "DelayedDiskWrite";
+
+        static void write (final List<EthernetConfiguration> networks) {
+
+            /* Do a delayed write to disk on a seperate handler thread */
+            synchronized (DelayedDiskWrite.class) {
+                if (++sWriteSequence == 1) {
+                    sDiskWriteHandlerThread = new HandlerThread("EthernetConfigThread");
+                    sDiskWriteHandlerThread.start();
+                    sDiskWriteHandler = new Handler(sDiskWriteHandlerThread.getLooper());
+                }
+            }
+
+            sDiskWriteHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        onWriteCalled(networks);
+                    }
+                });
+        }
+
+        private static void onWriteCalled(List<EthernetConfiguration> networks) {
+
+            DataOutputStream out = null;
+            try {
+                out = new DataOutputStream(new BufferedOutputStream(
+                            new FileOutputStream(ipConfigFile)));
+
+                out.writeInt(IPCONFIG_FILE_VERSION);
+
+                for(EthernetConfiguration config : networks) {
+                    boolean writeToFile = false;
+
+                    try {
+                        LinkProperties linkProperties = config.linkProperties;
+                        switch (config.ipAssignment) {
+                            case STATIC:
+                                out.writeUTF(IP_ASSIGNMENT_KEY);
+                                out.writeUTF(config.ipAssignment.toString());
+                                for (LinkAddress linkAddr : linkProperties.getLinkAddresses()) {
+                                    out.writeUTF(LINK_ADDRESS_KEY);
+                                    out.writeUTF(linkAddr.getAddress().getHostAddress());
+                                    out.writeInt(linkAddr.getNetworkPrefixLength());
+                                }
+                                for (RouteInfo route : linkProperties.getRoutes()) {
+                                    out.writeUTF(GATEWAY_KEY);
+                                    LinkAddress dest = route.getDestination();
+                                    if (dest != null) {
+                                        out.writeInt(1);
+                                        out.writeUTF(dest.getAddress().getHostAddress());
+                                        out.writeInt(dest.getNetworkPrefixLength());
+                                    } else {
+                                        out.writeInt(0);
+                                    }
+                                    if (route.getGateway() != null) {
+                                        out.writeInt(1);
+                                        out.writeUTF(route.getGateway().getHostAddress());
+                                    } else {
+                                        out.writeInt(0);
+                                    }
+                                }
+                                for (InetAddress inetAddr : linkProperties.getDnses()) {
+                                    out.writeUTF(DNS_KEY);
+                                    out.writeUTF(inetAddr.getHostAddress());
+                                }
+                                writeToFile = true;
+                                break;
+                            case DHCP:
+                                out.writeUTF(IP_ASSIGNMENT_KEY);
+                                out.writeUTF(config.ipAssignment.toString());
+                                writeToFile = true;
+                                break;
+                            case UNASSIGNED:
+                                /* Ignore */
+                                break;
+                            default:
+                                loge("Ignore invalid ip assignment while writing");
+                                break;
+                        }
+
+                        switch (config.proxySettings) {
+                            case STATIC:
+                                ProxyProperties proxyProperties = linkProperties.getHttpProxy();
+                                String exclusionList = proxyProperties.getExclusionList();
+                                out.writeUTF(PROXY_SETTINGS_KEY);
+                                out.writeUTF(config.proxySettings.toString());
+                                out.writeUTF(PROXY_HOST_KEY);
+                                out.writeUTF(proxyProperties.getHost());
+                                out.writeUTF(PROXY_PORT_KEY);
+                                out.writeInt(proxyProperties.getPort());
+                                out.writeUTF(EXCLUSION_LIST_KEY);
+                                out.writeUTF(exclusionList);
+                                writeToFile = true;
+                                break;
+                            case NONE:
+                                out.writeUTF(PROXY_SETTINGS_KEY);
+                                out.writeUTF(config.proxySettings.toString());
+                                writeToFile = true;
+                                break;
+                            case UNASSIGNED:
+                                /* Ignore */
+                                break;
+                            default:
+                                loge("Ignthisore invalid proxy settings while writing");
+                                break;
+                        }
+                        if (writeToFile) {
+                            out.writeUTF(ID_KEY);
+                            out.writeInt(configKey(config));
+                        }
+                    } catch (NullPointerException e) {
+                        loge("Failure in writing " + config.linkProperties + e);
+                    }
+                    out.writeUTF(EOS);
+                }
+
+            } catch (IOException e) {
+                loge("Error writing data file");
+            } finally {
+                if (out != null) {
+                    try {
+                        out.close();
+                    } catch (Exception e) {}
+                }
+
+                //Quit if no more writes sent
+                synchronized (DelayedDiskWrite.class) {
+                    if (--sWriteSequence == 0) {
+                        sDiskWriteHandler.getLooper().quit();
+                        sDiskWriteHandler = null;
+                        sDiskWriteHandlerThread = null;
+                    }
+                }
+            }
+        }
+
+        private static void loge(String s) {
+            Log.e(TAG, s);
+        }
+    }
+
+    private void readIpAndProxyConfigurations() {
+
+        DataInputStream in = null;
+        try {
+            in = new DataInputStream(new BufferedInputStream(new FileInputStream(
+                    ipConfigFile)));
+
+            int version = in.readInt();
+            if (version != 2 && version != 1) {
+                loge("Bad version on IP configuration file, ignore read");
+                return;
+            }
+
+            while (true) {
+                int id = -1;
+                IpAssignment ipAssignment = IpAssignment.UNASSIGNED;
+                ProxySettings proxySettings = ProxySettings.UNASSIGNED;
+                LinkProperties linkProperties = new LinkProperties();
+                String proxyHost = null;
+                int proxyPort = -1;
+                String exclusionList = null;
+                String key;
+
+                do {
+                    key = in.readUTF();
+                    try {
+                        if (key.equals(ID_KEY)) {
+                            id = in.readInt();
+                        } else if (key.equals(IP_ASSIGNMENT_KEY)) {
+                            ipAssignment = IpAssignment.valueOf(in.readUTF());
+                        } else if (key.equals(LINK_ADDRESS_KEY)) {
+                            LinkAddress linkAddr = new LinkAddress(
+                                    NetworkUtils.numericToInetAddress(in.readUTF()), in.readInt());
+                            linkProperties.addLinkAddress(linkAddr);
+                        } else if (key.equals(GATEWAY_KEY)) {
+                            LinkAddress dest = null;
+                            InetAddress gateway = null;
+                            if (version == 1) {
+                                // only supported default gateways - leave the dest/prefix empty
+                                gateway = NetworkUtils.numericToInetAddress(in.readUTF());
+                            } else {
+                                if (in.readInt() == 1) {
+                                    dest = new LinkAddress(
+                                            NetworkUtils.numericToInetAddress(in.readUTF()),
+                                            in.readInt());
+                                }
+                                if (in.readInt() == 1) {
+                                    gateway = NetworkUtils.numericToInetAddress(in.readUTF());
+                                }
+                            }
+                            linkProperties.addRoute(new RouteInfo(dest, gateway));
+                        } else if (key.equals(DNS_KEY)) {
+                            linkProperties.addDns(
+                                    NetworkUtils.numericToInetAddress(in.readUTF()));
+                        } else if (key.equals(PROXY_SETTINGS_KEY)) {
+                            proxySettings = ProxySettings.valueOf(in.readUTF());
+                        } else if (key.equals(PROXY_HOST_KEY)) {
+                            proxyHost = in.readUTF();
+                        } else if (key.equals(PROXY_PORT_KEY)) {
+                            proxyPort = in.readInt();
+                        } else if (key.equals(EXCLUSION_LIST_KEY)) {
+                            exclusionList = in.readUTF();
+                        } else if (key.equals(EOS)) {
+                            break;
+                        } else {
+                            loge("Ignore unknown key " + key + "while reading");
+                        }
+                    } catch (IllegalArgumentException e) {
+                        loge("Ignore invalid address while reading" + e);
+                    }
+                } while (true);
+
+                if (id != -1) {
+                    EthernetConfiguration config = mConfiguredNetworks.get(
+                            mNetworkIds.get(id));
+
+                    if (config == null) {
+                        loge("configuration found for missing network, ignored");
+                    } else {
+                        config.linkProperties = linkProperties;
+                        switch (ipAssignment) {
+                            case STATIC:
+                            case DHCP:
+                                config.ipAssignment = ipAssignment;
+                                break;
+                            case UNASSIGNED:
+                                //Ignore
+                                break;
+                            default:
+                                loge("Ignore invalid ip assignment while reading");
+                                break;
+                        }
+
+                        switch (proxySettings) {
+                            case STATIC:
+                                config.proxySettings = proxySettings;
+                                ProxyProperties proxyProperties =
+                                    new ProxyProperties(proxyHost, proxyPort, exclusionList);
+                                linkProperties.setHttpProxy(proxyProperties);
+                                break;
+                            case NONE:
+                                config.proxySettings = proxySettings;
+                                break;
+                            case UNASSIGNED:
+                                //Ignore
+                                break;
+                            default:
+                                loge("Ignore invalid proxy settings while reading");
+                                break;
+                        }
+                    }
+                } else {
+                    if (DBG) log("Missing id while parsing configuration");
+                }
+            }
+        } catch (EOFException ignore) {
+        } catch (IOException e) {
+            loge("Error parsing configuration" + e);
+        } finally {
+            if (in != null) {
+                try {
+                    in.close();
+                } catch (Exception e) {}
+            }
+        }
+    }
+
+    private NetworkUpdateResult addOrUpdateNetworkNative(EthernetConfiguration config) {
+        /*
+         * If the supplied networkId is INVALID_NETWORK_ID, we create a new empty
+         * network configuration. Otherwise, the networkId should
+         * refer to an existing configuration.
+         */
+        int netId = config.networkId;
+        boolean newNetwork = false;
+        // networkId of INVALID_NETWORK_ID means we want to create a new network
+        if (netId == INVALID_NETWORK_ID) {
+            Integer savedNetId = mNetworkIds.get(configKey(config));
+            if (savedNetId != null) {
+                netId = savedNetId;
+            } else {
+                newNetwork = true;
+                netId = mEthernetNative.addNetwork();
+                if (netId < 0) {
+                    loge("Failed to add a network!");
+                    return new NetworkUpdateResult(INVALID_NETWORK_ID);
+                }
+            }
+        }
+
+        boolean updateFailed = true;
+
+        setVariables: {
+
+            if (config.networkName != null &&
+                    !mEthernetNative.setNetworkVariable(
+                        netId,
+                        EthernetConfiguration.networkNameVarName,
+                        config.networkName)) {
+                loge("failed to set network name: " + config.networkName);
+                break setVariables;
+            }
+
+            if (!mEthernetNative.setNetworkVariable(
+                        netId,
+                        EthernetConfiguration.priorityVarName,
+                        Integer.toString(config.priority))) {
+                loge(config.networkName + ": failed to set priority: "
+                        + config.priority);
+                break setVariables;
+            }
+
+            updateFailed = false;
+        }
+
+        if (updateFailed) {
+            if (newNetwork) {
+                mEthernetNative.removeNetwork(netId);
+                loge("Failed to set a network variable, removed network: " + netId);
+            }
+            return new NetworkUpdateResult(INVALID_NETWORK_ID);
+        }
+
+        EthernetConfiguration currentConfig = mConfiguredNetworks.get(netId);
+        if (currentConfig == null) {
+            currentConfig = new EthernetConfiguration();
+            currentConfig.networkId = netId;
+        }
+
+        readNetworkVariables(currentConfig);
+
+        mConfiguredNetworks.put(netId, currentConfig);
+        mNetworkIds.put(configKey(currentConfig), netId);
+
+        NetworkUpdateResult result = writeIpAndProxyConfigurationsOnChange(currentConfig, config);
+        result.setIsNewNetwork(newNetwork);
+        result.setNetworkId(netId);
+        return result;
+    }
+
+    /* Compare current and new configuration and write to file on change */
+    private NetworkUpdateResult writeIpAndProxyConfigurationsOnChange(
+            EthernetConfiguration currentConfig,
+            EthernetConfiguration newConfig) {
+        boolean ipChanged = false;
+        boolean proxyChanged = false;
+        LinkProperties linkProperties = new LinkProperties();
+
+        switch (newConfig.ipAssignment) {
+            case STATIC:
+                Collection<LinkAddress> currentLinkAddresses = currentConfig.linkProperties
+                        .getLinkAddresses();
+                Collection<LinkAddress> newLinkAddresses = newConfig.linkProperties
+                        .getLinkAddresses();
+                Collection<InetAddress> currentDnses = currentConfig.linkProperties.getDnses();
+                Collection<InetAddress> newDnses = newConfig.linkProperties.getDnses();
+                Collection<RouteInfo> currentRoutes = currentConfig.linkProperties.getRoutes();
+                Collection<RouteInfo> newRoutes = newConfig.linkProperties.getRoutes();
+
+                boolean linkAddressesDiffer =
+                        (currentLinkAddresses.size() != newLinkAddresses.size()) ||
+                        !currentLinkAddresses.containsAll(newLinkAddresses);
+                boolean dnsesDiffer = (currentDnses.size() != newDnses.size()) ||
+                        !currentDnses.containsAll(newDnses);
+                boolean routesDiffer = (currentRoutes.size() != newRoutes.size()) ||
+                        !currentRoutes.containsAll(newRoutes);
+
+                if ((currentConfig.ipAssignment != newConfig.ipAssignment) ||
+                        linkAddressesDiffer ||
+                        dnsesDiffer ||
+                        routesDiffer) {
+                    ipChanged = true;
+                }
+                break;
+            case DHCP:
+                if (currentConfig.ipAssignment != newConfig.ipAssignment) {
+                    ipChanged = true;
+                }
+                break;
+            case UNASSIGNED:
+                /* Ignore */
+                break;
+            default:
+                loge("Ignore invalid ip assignment during write");
+                break;
+        }
+
+        switch (newConfig.proxySettings) {
+            case STATIC:
+                ProxyProperties newHttpProxy = newConfig.linkProperties.getHttpProxy();
+                ProxyProperties currentHttpProxy = currentConfig.linkProperties.getHttpProxy();
+
+                if (newHttpProxy != null) {
+                    proxyChanged = !newHttpProxy.equals(currentHttpProxy);
+                } else {
+                    proxyChanged = (currentHttpProxy != null);
+                }
+                break;
+            case NONE:
+                if (currentConfig.proxySettings != newConfig.proxySettings) {
+                    proxyChanged = true;
+                }
+                break;
+            case UNASSIGNED:
+                /* Ignore */
+                break;
+            default:
+                loge("Ignore invalid proxy configuration during write");
+                break;
+        }
+
+        if (!ipChanged) {
+            addIpSettingsFromConfig(linkProperties, currentConfig);
+        } else {
+            currentConfig.ipAssignment = newConfig.ipAssignment;
+            addIpSettingsFromConfig(linkProperties, newConfig);
+            log("IP config changed network name = " + currentConfig.networkName + " linkProperties: " +
+                    linkProperties.toString());
+        }
+
+        if (!proxyChanged) {
+            linkProperties.setHttpProxy(currentConfig.linkProperties.getHttpProxy());
+        } else {
+            currentConfig.proxySettings = newConfig.proxySettings;
+            linkProperties.setHttpProxy(newConfig.linkProperties.getHttpProxy());
+            log("proxy changed network name = " + currentConfig.networkName);
+            if (linkProperties.getHttpProxy() != null) {
+                log(" proxyProperties: " + linkProperties.getHttpProxy().toString());
+            }
+        }
+
+        if (ipChanged || proxyChanged) {
+            currentConfig.linkProperties = linkProperties;
+            writeIpAndProxyConfigurations();
+            sendConfiguredNetworksChangedBroadcast(currentConfig,
+                    EthernetManager.CHANGE_REASON_CONFIG_CHANGE);
+        }
+        return new NetworkUpdateResult(ipChanged, proxyChanged);
+    }
+
+    private void addIpSettingsFromConfig(LinkProperties linkProperties,
+            EthernetConfiguration config) {
+        for (LinkAddress linkAddr : config.linkProperties.getLinkAddresses()) {
+            linkProperties.addLinkAddress(linkAddr);
+        }
+        for (RouteInfo route : config.linkProperties.getRoutes()) {
+            linkProperties.addRoute(route);
+        }
+        for (InetAddress dns : config.linkProperties.getDnses()) {
+            linkProperties.addDns(dns);
+        }
+    }
+
+    /**
+     * Read the variables that are needed to
+     * fill in the EthernetConfiguration object.
+     *
+     * @param config the {@link EthernetConfiguration} object to be filled in.
+     */
+    private void readNetworkVariables(EthernetConfiguration config) {
+
+        int netId = config.networkId;
+        if (netId < 0)
+            return;
+
+        /*
+         * TODO: maybe should have a native method that takes an array of
+         * variable names and returns an array of values. But we'd still
+         * be doing a round trip to the supplicant daemon for each variable.
+         */
+        String value;
+
+        value = mEthernetNative.getNetworkVariable(netId, EthernetConfiguration.networkNameVarName);
+        if (!TextUtils.isEmpty(value)) {
+	    config.networkName = value;
+        } else {
+            config.networkName = null;
+        }
+
+        value = mEthernetNative.getNetworkVariable(netId, EthernetConfiguration.priorityVarName);
+        config.priority = -1;
+        if (!TextUtils.isEmpty(value)) {
+            try {
+                config.priority = Integer.parseInt(value);
+            } catch (NumberFormatException ignore) {
+            }
+        }
+    }
+
+    /* Returns a unique for a given configuration */
+    private static int configKey(EthernetConfiguration config) {
+
+        String key = config.networkName;
+
+        return key.hashCode();
+    }
+
+    String dump() {
+        StringBuffer sb = new StringBuffer();
+        String LS = System.getProperty("line.separator");
+        sb.append("mLastPriority ").append(mLastPriority).append(LS);
+        sb.append("Configured networks ").append(LS);
+        for (EthernetConfiguration conf : getConfiguredNetworks()) {
+            sb.append(conf).append(LS);
+        }
+        return sb.toString();
+    }
+
+    public String getConfigFile() {
+        return ipConfigFile;
+    }
+
+    private void loge(String s) {
+        Log.e(TAG, s);
+    }
+
+    private void log(String s) {
+        Log.d(TAG, s);
+    }
+}
diff --git a/ethernet/java/android/net/ethernet/EthernetConfiguration.aidl b/ethernet/java/android/net/ethernet/EthernetConfiguration.aidl
new file mode 100644
index 0000000..fff5ec0
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/EthernetConfiguration.aidl
@@ -0,0 +1,19 @@
+/**
+ * Copyright (c) 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ */
+
+package android.net.ethernet;
+
+parcelable EthernetConfiguration;
diff --git a/ethernet/java/android/net/ethernet/EthernetConfiguration.java b/ethernet/java/android/net/ethernet/EthernetConfiguration.java
new file mode 100644
index 0000000..9afaad1
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/EthernetConfiguration.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.ethernet;
+
+import android.net.LinkProperties;
+import android.os.Parcelable;
+import android.os.Parcel;
+
+/**
+ * A class representing a configured Ethernet network.
+ */
+public class EthernetConfiguration implements Parcelable {
+
+    /** {@hide} */
+    public static final String networkVarName = "name";
+
+    /** {@hide} */
+    public static final String priorityVarName = "priority";
+
+    /** {@hide} */
+    public static final int INVALID_NETWORK_ID = -1;
+
+    /** Possible status of a network configuration. */
+    public static class Status {
+        private Status() { }
+
+        /** this is the network we are currently connected to */
+        public static final int CURRENT = 0;
+        /** will not attempt to use this network */
+        public static final int DISABLED = 1;
+        /** will consider this network available for connection */
+        public static final int ENABLED = 2;
+
+        public static final String[] strings = { "current", "disabled", "enabled" };
+    }
+
+    /** @hide */
+    public static final int DISABLED_UNKNOWN_REASON                         = 0;
+    /** @hide */
+    public static final int DISABLED_DNS_FAILURE                            = 1;
+    /** @hide */
+    public static final int DISABLED_DHCP_FAILURE                           = 2;
+
+    /**
+     * The ID number that the supplicant uses to identify this
+     * network configuration entry. This must be passed as an argument
+     * to most calls into the supplicant.
+     */
+    public int networkId;
+
+    /**
+     * The current status of this network configuration entry.
+     * @see Status
+     */
+    public int status;
+
+    /**
+     * The code referring to a reason for disabling the network
+     * Valid when {@link #status} == Status.DISABLED
+     * @hide
+     */
+    public int disableReason;
+
+    /**
+     * The network's name.
+     * An ASCII string, which must be enclosed in double quotation marks
+     * (e.g., {@code "MyNetwork"}).
+     */
+    public String networkName;
+
+    /**
+     * Priority determines the preference given to a network
+     * when choosing a link to connect to.
+     */
+    public int priority;
+
+    /**
+     * @hide
+     */
+    public enum IpAssignment {
+        /* Use statically configured IP settings. Configuration can be accessed
+         * with linkProperties */
+        STATIC,
+        /* Use dynamically configured IP settigns */
+        DHCP,
+        /* no IP details are assigned, this is used to indicate
+         * that any existing IP settings should be retained */
+        UNASSIGNED
+    }
+    /**
+     * @hide
+     */
+    public IpAssignment ipAssignment;
+
+    /**
+     * @hide
+     */
+    public enum ProxySettings {
+        /* No proxy is to be used. Any existing proxy settings
+         * should be cleared. */
+        NONE,
+        /* Use statically configured proxy. Configuration can be accessed
+         * with linkProperties */
+        STATIC,
+        /* no proxy details are assigned, this is used to indicate
+         * that any existing proxy settings should be retained */
+        UNASSIGNED
+    }
+
+    /**
+     * @hide
+     */
+    public ProxySettings proxySettings;
+
+    /**
+     * @hide
+     */
+    public LinkProperties linkProperties;
+
+    public EthernetConfiguration() {
+        networkId = INVALID_NETWORK_ID;
+	networkName = null;
+	priority = 0;
+	disableReason = DISABLED_UNKNOWN_REASON;
+        ipAssignment = IpAssignment.UNASSIGNED;
+        proxySettings = ProxySettings.UNASSIGNED;
+        linkProperties = new LinkProperties();
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sbuf = new StringBuilder();
+
+	if (this.status == EthernetConfiguration.Status.CURRENT) {
+            sbuf.append("* ");
+        } else if (this.status == EthernetConfiguration.Status.DISABLED) {
+            sbuf.append("- DISABLE: ").append(this.disableReason).append(" ");
+        }
+
+        sbuf.append("ID: ").append(this.networkId);
+        sbuf.append('\n');
+        sbuf.append("Name: ").append(this.networkName);
+        sbuf.append('\n');
+        sbuf.append("Priority: ").append(this.priority);
+        sbuf.append('\n');
+        sbuf.append("IP assignment: " + ipAssignment.toString());
+        sbuf.append("\n");
+        sbuf.append("Proxy settings: " + proxySettings.toString());
+        sbuf.append("\n");
+        sbuf.append(linkProperties.toString());
+        sbuf.append("\n");
+
+        return sbuf.toString();
+    }
+
+    /** Implement the Parcelable interface {@hide} */
+    public int describeContents() {
+        return 0;
+    }
+
+    /** copy constructor {@hide} */
+    public EthernetConfiguration(EthernetConfiguration source) {
+        if (source != null) {
+            networkId = source.networkId;
+	    status = source.status;
+            disableReason = source.disableReason;
+            networkName = source.networkName;
+            priority = source.priority;
+            ipAssignment = source.ipAssignment;
+            proxySettings = source.proxySettings;
+            linkProperties = new LinkProperties(source.linkProperties);
+        }
+    }
+
+    /** Implement the Parcelable interface {@hide} */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(networkId);
+	dest.writeInt(status);
+        dest.writeInt(disableReason);
+        dest.writeString(networkName);
+        dest.writeInt(priority);
+        dest.writeString(ipAssignment.name());
+        dest.writeString(proxySettings.name());
+        dest.writeParcelable(linkProperties, flags);
+    }
+
+    /** Implement the Parcelable interface {@hide} */
+    public static final Creator<EthernetConfiguration> CREATOR =
+        new Creator<EthernetConfiguration>() {
+            public EthernetConfiguration createFromParcel(Parcel in) {
+                EthernetConfiguration config = new EthernetConfiguration();
+                config.networkId = in.readInt();
+		config.status = in.readInt();
+                config.disableReason = in.readInt();
+                config.networkName = in.readString();
+                config.priority = in.readInt();
+                config.ipAssignment = IpAssignment.valueOf(in.readString());
+                config.proxySettings = ProxySettings.valueOf(in.readString());
+                config.linkProperties = in.readParcelable(null);
+                return config;
+            }
+
+            public EthernetConfiguration[] newArray(int size) {
+                return new EthernetConfiguration[size];
+            }
+        };
+}
diff --git a/ethernet/java/android/net/ethernet/EthernetInfo.aidl b/ethernet/java/android/net/ethernet/EthernetInfo.aidl
new file mode 100644
index 0000000..4cda6a7
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/EthernetInfo.aidl
@@ -0,0 +1,19 @@
+/**
+ * Copyright (c) 2008, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ */
+
+package android.net.ethernet;
+
+parcelable EthernetInfo;
diff --git a/ethernet/java/android/net/ethernet/EthernetInfo.java b/ethernet/java/android/net/ethernet/EthernetInfo.java
new file mode 100644
index 0000000..8a82404
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/EthernetInfo.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.ethernet;
+
+import android.os.Parcelable;
+import android.os.Parcel;
+import android.net.NetworkInfo.DetailedState;
+import android.net.NetworkUtils;
+import android.text.TextUtils;
+
+import java.net.InetAddress;
+import java.net.Inet6Address;
+import java.net.UnknownHostException;
+
+/**
+ * Describes the state of any Ethernet connection that is active or
+ * is in the process of being set up.
+ */
+public class EthernetInfo implements Parcelable {
+    private static final String TAG = "EthernetInfo";
+
+    private int mNetworkId;
+    private String networkName;
+
+    /** Link speed in Mbps */
+    public static final String LINK_SPEED_UNITS = "Mbps";
+    private int mLinkSpeed;
+
+    private InetAddress mIpAddress;
+    private String mMacAddress;
+
+    EthernetInfo() {
+        mNetworkId = -1;
+        mNetworkName = null;
+        mLinkSpeed = -1;
+    }
+
+    /**
+     * Copy constructor
+     * @hide
+     */
+    public EthernetInfo(EthernetInfo source) {
+        if (source != null) {
+            mNetworkId = source.mNetworkId;
+            mNetworkName = source.mNetworkName;
+            mLinkSpeed = source.mLinkSpeed;
+            mIpAddress = source.mIpAddress;
+            mMacAddress = source.mMacAddress;
+        }
+    }
+
+    void setName(String networkName) {
+        mNetworkName = networkName;
+    }
+
+    /**
+     * Returns the name 802.3 network.
+     * It will be returned surrounded by double quotation marks.
+     * The name may be {@code null} if there is no network currently connected.
+     * @return the name
+     */
+    public String getName() {
+        if (mNetworkName != null) {
+            String unicode = mNetworkName.toString();
+	    return "\"" + unicode + "\"";
+        }
+        return null;
+    }
+
+    /** @hide */
+    public String getEthernetName() {
+        return mNetworkName;
+    }
+
+    /**
+     * Returns the current link speed in {@link #LINK_SPEED_UNITS}.
+     * @return the link speed.
+     * @see #LINK_SPEED_UNITS
+     */
+    public int getLinkSpeed() {
+        return mLinkSpeed;
+    }
+
+    void setLinkSpeed(int linkSpeed) {
+        this.mLinkSpeed = linkSpeed;
+    }
+
+    /**
+     * Record the MAC address of the LAN interface
+     * @param macAddress the MAC address in {@code XX:XX:XX:XX:XX:XX} form
+     */
+    void setMacAddress(String macAddress) {
+        this.mMacAddress = macAddress;
+    }
+
+    public String getMacAddress() {
+        return mMacAddress;
+    }
+
+    void setNetworkId(int id) {
+        mNetworkId = id;
+    }
+
+    /**
+     * Each configured network has a unique small integer ID, used to identify
+     * the network when performing operations on the supplicant. This method
+     * returns the ID for the currently connected network.
+     * @return the network ID, or -1 if there is no currently connected network
+     */
+    public int getNetworkId() {
+        return mNetworkId;
+    }
+
+    void setInetAddress(InetAddress address) {
+        mIpAddress = address;
+    }
+
+    public int getIpAddress() {
+        if (mIpAddress == null || mIpAddress instanceof Inet6Address) return 0;
+        return NetworkUtils.inetAddressToInt(mIpAddress);
+    }
+
+    @Override
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        String none = "<none>";
+
+	sb.append("Name: ").append(mNetworkName == null ? "" : mNetworkName).
+	   append(", MAC: ").append(mMacAddress == null ? none : mMacAddress).
+           append(", Link speed: ").append(mLinkSpeed).
+           append(", Net ID: ").append(mNetworkId);
+
+        return sb.toString();
+    }
+
+    /** Implement the Parcelable interface {@hide} */
+    public int describeContents() {
+        return 0;
+    }
+
+    /** Implement the Parcelable interface {@hide} */
+    public void writeToParcel(Parcel dest, int flags) {
+	dest.writeString(mNetworkName);
+        dest.writeInt(mNetworkId);
+        dest.writeInt(mLinkSpeed);
+        if (mIpAddress != null) {
+            dest.writeByte((byte)1);
+            dest.writeByteArray(mIpAddress.getAddress());
+        } else {
+            dest.writeByte((byte)0);
+        }
+	dest.writeString(mMacAddress);
+    }
+
+    /** Implement the Parcelable interface {@hide} */
+    public static final Creator<EthernetInfo> CREATOR =
+        new Creator<EthernetInfo>() {
+            public EthernetInfo createFromParcel(Parcel in) {
+                EthernetInfo info = new EthernetInfo();
+                info.setName(in.readString());
+                info.setNetworkId(in.readInt());
+                info.setLinkSpeed(in.readInt());
+                if (in.readByte() == 1) {
+                    try {
+                        info.setInetAddress(InetAddress.getByAddress(in.createByteArray()));
+                    } catch (UnknownHostException e) {}
+                }
+                info.mMacAddress = in.readString();
+
+                return info;
+            }
+
+            public EthernetInfo[] newArray(int size) {
+                return new EthernetInfo[size];
+            }
+        };
+}
diff --git a/ethernet/java/android/net/ethernet/EthernetManager.java b/ethernet/java/android/net/ethernet/EthernetManager.java
new file mode 100644
index 0000000..a4e1345
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/EthernetManager.java
@@ -0,0 +1,1394 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.ethernet;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.content.Context;
+import android.net.DhcpInfo;
+import android.os.Binder;
+import android.os.IBinder;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.WorkSource;
+import android.os.Messenger;
+import android.util.Log;
+import android.util.SparseArray;
+
+import java.util.concurrent.CountDownLatch;
+
+import com.android.internal.util.AsyncChannel;
+import com.android.internal.util.Protocol;
+
+import java.util.List;
+
+/**
+ * This class provides the primary API for managing all aspects of Ethernet
+ * connectivity. Get an instance of this class by calling
+ * {@link android.content.Context#getSystemService(String) Context.getSystemService(Context.ETHERNET_SERVICE)}.
+
+ * It deals with several categories of items:
+ * <ul>
+ * <li>Ethernet connectivity can be established or torn down, and dynamic
+ * information about the state of the network can be queried.</li>
+ * <li>It defines the names of various Intent actions that are broadcast
+ * upon any sort of change in Ethernet state.
+ * </ul>
+ * This is the API to use when performing Ethernet specific operations. To
+ * perform operations that pertain to network connectivity at an abstract
+ * level, use {@link android.net.ConnectivityManager}.
+ */
+public class EthernetManager {
+
+    private static final String TAG = "EthernetManager";
+
+    /**
+     * Broadcast intent action indicating that Ethernet has been enabled, disabled,
+     * enabling, disabling, or unknown. One extra provides this state as an int.
+     * Another extra provides the previous state, if available.
+     *
+     * @see #EXTRA_ETHERNET_STATE
+     * @see #EXTRA_PREVIOUS_ETHERNET_STATE
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ETHERNET_STATE_CHANGED_ACTION =
+        "android.net.ethernet.ETHERNET_STATE_CHANGED";
+
+    /**
+     * The lookup key for an int that indicates whether Ethernet is enabled,
+     * disabled, enabling, disabling, or unknown.  Retrieve it with
+     * {@link android.content.Intent#getIntExtra(String,int)}.
+     *
+     * @see #ETHERNET_STATE_DISABLED
+     * @see #ETHERNET_STATE_DISABLING
+     * @see #ETHERNET_STATE_ENABLED
+     * @see #ETHERNET_STATE_ENABLING
+     * @see #ETHERNET_STATE_UNKNOWN
+     */
+    public static final String EXTRA_ETHERNET_STATE = "ethernet_state";
+
+    /**
+     * The previous Ethernet state.
+     *
+     * @see #EXTRA_ETHERNET_STATE
+     */
+    public static final String EXTRA_PREVIOUS_ETHERNET_STATE = "previous_ethernet_state";
+
+    /**
+     * Ethernet is currently being disabled. The state will change to {@link #ETHERNET_STATE_DISABLED} if
+     * it finishes successfully.
+     *
+     * @see #ETHERNET_STATE_CHANGED_ACTION
+     * @see #getEthernetState()
+     */
+    public static final int ETHERNET_STATE_DISABLING = 0;
+
+    /**
+     * Ethernet is disabled.
+     *
+     * @see #ETHERNET_STATE_CHANGED_ACTION
+     * @see #getEthernetState()
+     */
+    public static final int ETHERNET_STATE_DISABLED = 1;
+
+    /**
+     * Ethernet is currently being enabled. The state will change to {@link #ETHERNET_STATE_ENABLED} if
+     * it finishes successfully.
+     *
+     * @see #ETHERNET_STATE_CHANGED_ACTION
+     * @see #getEthernetState()
+     */
+    public static final int ETHERNET_STATE_ENABLING = 2;
+
+    /**
+     * Ethernet is enabled.
+     *
+     * @see #ETHERNET_STATE_CHANGED_ACTION
+     * @see #getEthernetState()
+     */
+    public static final int ETHERNET_STATE_ENABLED = 3;
+
+    /**
+     * Ethernet is in an unknown state. This state will occur when an error happens while enabling
+     * or disabling.
+     *
+     * @see #ETHERNET_STATE_CHANGED_ACTION
+     * @see #getEthernetState()
+     */
+    public static final int ETHERNET_STATE_UNKNOWN = 4;
+
+    /**
+     * Broadcast intent action indicating that the state of Ethernet connectivity
+     * has changed. One extra provides the new state
+     * in the form of a {@link android.net.NetworkInfo} object. If the new
+     * state is CONNECTED, additional extras may provide the EthernetInfo of the link.
+     * as a {@code String}.
+     * @see #EXTRA_NETWORK_INFO
+     * @see #EXTRA_ETHERNET_INFO
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String NETWORK_STATE_CHANGED_ACTION = "android.net.ethernet.STATE_CHANGE";
+
+    /**
+     * The lookup key for a {@link android.net.NetworkInfo} object associated
+     * with the Ethernet network. Retrieve with
+     * {@link android.content.Intent#getParcelableExtra(String)}.
+     */
+    public static final String EXTRA_NETWORK_INFO = "networkInfo";
+
+    /**
+     * The lookup key for a {@link android.net.ethernet.EthernetInfo} object giving the
+     * information about the link to which we are connected. Only present
+     * when the new state is CONNECTED.  Retrieve with
+     * {@link android.content.Intent#getParcelableExtra(String)}.
+     */
+    public static final String EXTRA_ETHERNET_INFO = "ethernetInfo";
+
+    /**
+     * Broadcast intent action indicating that the configured networks changed.
+     * This can be as a result of adding/updating/deleting a network. If
+     * {@link #EXTRA_MULTIPLE_NETWORKS_CHANGED} is set to true the new configuration
+     * can be retreived with the {@link #EXTRA_ETHERNET_CONFIGURATION} extra. If multiple
+     * Ethernet configurations changed, {@link #EXTRA_ETHERNET_CONFIGURATION} will not be present.
+     * @hide
+     */
+    public static final String CONFIGURED_NETWORKS_CHANGED_ACTION =
+        "android.net.ethernet.CONFIGURED_NETWORKS_CHANGE";
+
+    /**
+     * The lookup key for a (@link android.net.ethernet.EthernetConfiguration} object representing
+     * the changed Ethernet configuration when the {@link #CONFIGURED_NETWORKS_CHANGED_ACTION}
+     * broadcast is sent.
+     * @hide
+     */
+    public static final String EXTRA_ETHERNET_CONFIGURATION = "ethernetConfiguration";
+
+    /**
+     * Multiple network configurations have changed.
+     * @see #CONFIGURED_NETWORKS_CHANGED_ACTION
+     *
+     * @hide
+     */
+    public static final String EXTRA_MULTIPLE_NETWORKS_CHANGED = "multipleChanges";
+
+    /**
+     * The lookup key for an integer indicating the reason an Ethernet network configuration
+     * has changed. Only present if {@link #EXTRA_MULTIPLE_NETWORKS_CHANGED} is {@code false}
+     * @see #CONFIGURED_NETWORKS_CHANGED_ACTION
+     * @hide
+     */
+    public static final String EXTRA_CHANGE_REASON = "changeReason";
+
+    /**
+     * The configuration is new and was added.
+     * @hide
+     */
+    public static final int CHANGE_REASON_ADDED = 0;
+
+    /**
+     * The configuration was removed and is no longer present in the system's list of
+     * configured networks.
+     * @hide
+     */
+    public static final int CHANGE_REASON_REMOVED = 1;
+
+    /**
+     * The configuration has changed as a result of explicit action or because the system
+     * took an automated action such as disabling a malfunctioning configuration.
+     * @hide
+     */
+    public static final int CHANGE_REASON_CONFIG_CHANGE = 2;
+
+    /**
+     * Broadcast intent action indicating that the link configuration
+     * changed on ethernet.
+     * @hide
+     */
+    public static final String LINK_CONFIGURATION_CHANGED_ACTION =
+        "android.net.ethernet.LINK_CONFIGURATION_CHANGED";
+
+    /**
+     * The lookup key for a {@link android.net.LinkProperties} object
+     * associated with the Ethernet network. Retrieve with
+     * {@link android.content.Intent#getParcelableExtra(String)}.
+     * @hide
+     */
+    public static final String EXTRA_LINK_PROPERTIES = "linkProperties";
+
+    /**
+     * The lookup key for a {@link android.net.LinkCapabilities} object
+     * associated with the Ethernet network. Retrieve with
+     * {@link android.content.Intent#getParcelableExtra(String)}.
+     * @hide
+     */
+    public static final String EXTRA_LINK_CAPABILITIES = "linkCapabilities";
+
+    /**
+     * The network IDs of the configured networks could have changed.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String NETWORK_IDS_CHANGED_ACTION = "android.net.ethernet.NETWORK_IDS_CHANGED";
+
+    /**
+     * Activity Action: Pick an Ethernet network to connect to.
+     * <p>Input: Nothing.
+     * <p>Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_PICK_ETHERNET_NETWORK = "android.net.ethernet.PICK_ETHERNET_NETWORK";
+
+    /**
+     * In this Ethernet lock mode, Ethernet will be kept active,
+     * and will behave normally, i.e., it will attempt to automatically
+     * establish a connection to a remembered link.
+     */
+    public static final int ETHERNET_MODE_FULL = 1;
+
+    /**
+     * In this Ethernet lock mode, Ethernet will be kept active,
+     * but will only operated at Fast Ethernet (10/100) speed
+     * for energy saving.
+     */
+    public static final int ETHERNET_MODE_RESTRICTED_FE = 2;
+
+    /**
+     * In this Ethernet lock mode, Ethernet will be kept active as in mode
+     * {@link #ETHERNET_MODE_FULL} but it operates at high performance
+     * Gigabit (if supported by the hardware) with minimum packet loss and
+     * low packet latency even when the device screen is off.
+     * This mode will consume more power and hence should be used only when
+     * there is a need for such an active connection.
+     * <p>
+     * An example use case is when a voice connection needs to be
+     * kept active even after the device screen goes off. Holding the
+     * regular {@link #ETHERNET_MODE_FULL} lock will keep the ethernet
+     * connection active, but the connection can be lossy.
+     * Holding a {@link #ETHERNET_MODE_FULL_HIGH_PERF} lock for the
+     * duration of the voice call will improve the call quality.
+     * <p>
+     * When there is no support from the hardware, this lock mode
+     * will have the same behavior as {@link #ETHERNET_MODE_FULL}
+     */
+    public static final int ETHERNET_MODE_FULL_HIGH_PERF = 3;
+
+    /** List of asyncronous notifications
+     * @hide
+     */
+    public static final int DATA_ACTIVITY_NOTIFICATION = 1;
+
+    //Lowest bit indicates data reception and the second lowest
+    //bit indicates data transmitted
+    /** @hide */
+    public static final int DATA_ACTIVITY_NONE         = 0x00;
+    /** @hide */
+    public static final int DATA_ACTIVITY_IN           = 0x01;
+    /** @hide */
+    public static final int DATA_ACTIVITY_OUT          = 0x02;
+    /** @hide */
+    public static final int DATA_ACTIVITY_INOUT        = 0x03;
+
+    /* Maximum number of active locks we allow.
+     * This limit was added to prevent apps from creating a ridiculous number
+     * of locks and crashing the system by overflowing the global ref table.
+     */
+    private static final int MAX_ACTIVE_LOCKS = 50;
+
+    /* Number of currently active EthernetLocks and MulticastLocks */
+    private int mActiveLockCount;
+
+    private Context mContext;
+    IEthernetManager mService;
+
+    private static final int INVALID_KEY = 0;
+    private int mListenerKey = 1;
+    private final SparseArray mListenerMap = new SparseArray();
+    private final Object mListenerMapLock = new Object();
+
+    private AsyncChannel mAsyncChannel = new AsyncChannel();
+    private ServiceHandler mHandler;
+    private Messenger mEthernetServiceMessenger;
+    private final CountDownLatch mConnected = new CountDownLatch(1);
+
+    /**
+     * Create a new EthernetManager instance.
+     * Applications will almost always want to use
+     * {@link android.content.Context#getSystemService Context.getSystemService()} to retrieve
+     * the standard {@link android.content.Context#ETHERNET_SERVICE Context.ETHERNET_SERVICE}.
+     * @param context the application context
+     * @param service the Binder interface
+     * @hide - hide this because it takes in a parameter of type IEthernetManager, which
+     * is a system private class.
+     */
+    public EthernetManager(Context context, IEthernetManager service) {
+        mContext = context;
+        mService = service;
+        init();
+    }
+
+    /**
+     * Return a list of all the networks configured.
+     * Not all fields of EthernetConfiguration are returned. Only the following
+     * fields are filled in:
+     * <ul>
+     * <li>networkId</li>
+     * <li>networkName</li>
+     * <li>priority</li>
+     * </ul>
+     * @return a list of network configurations in the form of a list
+     * of {@link EthernetConfiguration} objects. Upon failure to fetch or
+     * when when Ethernet is turned off, it can be null.
+     */
+    public List<EthernetConfiguration> getConfiguredNetworks() {
+        try {
+            return mService.getConfiguredNetworks();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Add a new network description to the set of configured networks.
+     * The {@code networkId} field of the supplied configuration object
+     * is ignored.
+     * <p/>
+     * The new network will be marked DISABLED by default. To enable it,
+     * called {@link #enableNetwork}.
+     *
+     * @param config the set of variables that describe the configuration,
+     *            contained in a {@link EthernetConfiguration} object.
+     * @return the ID of the newly created network description. This is used in
+     *         other operations to specified the network to be acted upon.
+     *         Returns {@code -1} on failure.
+     */
+    public int addNetwork(EthernetConfiguration config) {
+        if (config == null) {
+            return -1;
+        }
+        config.networkId = -1;
+        return addOrUpdateNetwork(config);
+    }
+
+    /**
+     * Update the network description of an existing configured network.
+     *
+     * @param config the set of variables that describe the configuration,
+     *            contained in a {@link EthernetConfiguration} object. It may
+     *            be sparse, so that only the items that are being changed
+     *            are non-<code>null</code>. The {@code networkId} field
+     *            must be set to the ID of the existing network being updated.
+     * @return Returns the {@code networkId} of the supplied
+     *         {@code EthernetConfiguration} on success.
+     *         <br/>
+     *         Returns {@code -1} on failure, including when the {@code networkId}
+     *         field of the {@code EthernetConfiguration} does not refer to an
+     *         existing network.
+     */
+    public int updateNetwork(EthernetConfiguration config) {
+        if (config == null || config.networkId < 0) {
+            return -1;
+        }
+        return addOrUpdateNetwork(config);
+    }
+
+    /**
+     * Internal method for doing the RPC that creates a new network description
+     * or updates an existing one.
+     *
+     * @param config The possibly sparse object containing the variables that
+     *         are to set or updated in the network description.
+     * @return the ID of the network on success, {@code -1} on failure.
+     */
+    private int addOrUpdateNetwork(EthernetConfiguration config) {
+        try {
+            return mService.addOrUpdateNetwork(config);
+        } catch (RemoteException e) {
+            return -1;
+        }
+    }
+
+    /**
+     * Remove the specified network from the list of configured networks.
+     * This may result in the asynchronous delivery of state change
+     * events.
+     * @param netId the integer that identifies the network configuration
+     * to the supplicant
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean removeNetwork(int netId) {
+        try {
+            return mService.removeNetwork(netId);
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Allow a previously configured network to be connected to. If
+     * <code>disableOthers</code> is true, then all other configured
+     * networks are disabled, and an attempt to connect to the selected
+     * network is initiated. This may result in the asynchronous delivery
+     * of state change events.
+     * @param netId the ID of the network in the list of configured networks
+     * @param disableOthers if true, disable all other networks. The way to
+     * select a particular network to connect to is specify {@code true}
+     * for this parameter.
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean enableNetwork(int netId, boolean disableOthers) {
+        try {
+            return mService.enableNetwork(netId, disableOthers);
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Disable a configured network. The specified network will not be
+     * a candidate for associating. This may result in the asynchronous
+     * delivery of state change events.
+     * @param netId the ID of the network as returned by {@link #addNetwork}.
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean disableNetwork(int netId) {
+        try {
+            return mService.disableNetwork(netId);
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Disconnect from the currently active link. This may result
+     * in the asynchronous delivery of state change events.
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean disconnect() {
+        try {
+            mService.disconnect();
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Reconnect to the currently active link, if we are currently
+     * disconnected. This may result in the asynchronous delivery of state
+     * change events.
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean reconnect() {
+        try {
+            mService.reconnect();
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Return dynamic information about the current Ethernet connection, if any is active.
+     * @return the Ethernet information, contained in {@link EthernetInfo}.
+     */
+    public EthernetInfo getConnectionInfo() {
+        try {
+            return mService.getConnectionInfo();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Persist the current list of configured networks.
+     * <p>
+     * Note: It is possible for this method to change the network IDs of
+     * existing networks. You should assume the network IDs can be different
+     * after calling this method.
+     *
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean saveConfiguration() {
+        try {
+            return mService.saveConfiguration();
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Return the DHCP-assigned addresses from the last successful DHCP request,
+     * if any.
+     * @return the DHCP information
+     */
+    public DhcpInfo getDhcpInfo() {
+        try {
+            return mService.getDhcpInfo();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Enable or disable Ethernet.
+     * @param enabled {@code true} to enable, {@code false} to disable.
+     * @return {@code true} if the operation succeeds (or if the existing state
+     *         is the same as the requested state).
+     */
+    public boolean setEthernetEnabled(boolean enabled) {
+        try {
+            return mService.setEthernetEnabled(enabled);
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Gets the Ethernet enabled state.
+     * @return One of {@link #ETHERNET_STATE_DISABLED},
+     *         {@link #ETHERNET_STATE_DISABLING}, {@link #ETHERNET_STATE_ENABLED},
+     *         {@link #ETHERNET_STATE_ENABLING}, {@link #ETHERNET_STATE_UNKNOWN}
+     * @see #isEthernetEnabled()
+     */
+    public int getEthernetState() {
+        try {
+            return mService.getEthernetEnabledState();
+        } catch (RemoteException e) {
+            return ETHERNET_STATE_UNKNOWN;
+        }
+    }
+
+    /**
+     * Return whether Ethernet is enabled or disabled.
+     * @return {@code true} if Ethernet is enabled
+     * @see #getEthernetState()
+     */
+    public boolean isEthernetEnabled() {
+        return getEthernetState() == ETHERNET_STATE_ENABLED;
+    }
+
+   /**
+     * Start the driver and connect to network.
+     *
+     * This function will over-ride device idle status. For example,
+     * even if the device is idle,
+     * a start ethernet would mean that ethernet connection is kept active until
+     * a stopEthernet() is sent.
+     *
+     * This API is used by EthernetStateTracker
+     *
+     * @return {@code true} if the operation succeeds else {@code false}
+     * @hide
+     */
+    public boolean startEthernet() {
+        try {
+            mService.startEthernet();
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Disconnect from a network (if any) and stop the driver.
+     *
+     * This function will over-ride device idle status.
+     * Ethernet stays inactive until a startEthernet() is issued.
+     *
+     * This API is used by EthernetStateTracker
+     *
+     * @return {@code true} if the operation succeeds else {@code false}
+     * @hide
+     */
+    public boolean stopEthernet() {
+        try {
+            mService.stopEthernet();
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /* TODO: deprecate synchronous API and open up the following API */
+
+    private static final int BASE = Protocol.BASE_ETHERNET_MANAGER;
+
+    /* Commands to EthernetService */
+    /** @hide */
+    public static final int CONNECT_NETWORK                 = BASE + 1;
+    /** @hide */
+    public static final int CONNECT_NETWORK_FAILED          = BASE + 2;
+    /** @hide */
+    public static final int CONNECT_NETWORK_SUCCEEDED       = BASE + 3;
+
+    /** @hide */
+    public static final int FORGET_NETWORK                  = BASE + 4;
+    /** @hide */
+    public static final int FORGET_NETWORK_FAILED           = BASE + 5;
+    /** @hide */
+    public static final int FORGET_NETWORK_SUCCEEDED        = BASE + 6;
+
+    /** @hide */
+    public static final int SAVE_NETWORK                    = BASE + 7;
+    /** @hide */
+    public static final int SAVE_NETWORK_FAILED             = BASE + 8;
+    /** @hide */
+    public static final int SAVE_NETWORK_SUCCEEDED          = BASE + 9;
+
+    /** @hide */
+    public static final int DISABLE_NETWORK                 = BASE + 17;
+    /** @hide */
+    public static final int DISABLE_NETWORK_FAILED          = BASE + 18;
+    /** @hide */
+    public static final int DISABLE_NETWORK_SUCCEEDED       = BASE + 19;
+
+    /* For system use only */
+    /** @hide */
+    public static final int ENABLE_TRAFFIC_STATS_POLL       = BASE + 31;
+    /** @hide */
+    public static final int TRAFFIC_STATS_POLL              = BASE + 32;
+
+
+    /**
+     * Passed with {@link ActionListener#onFailure}.
+     * Indicates that the operation failed due to an internal error.
+     * @hide
+     */
+    public static final int ERROR                       = 0;
+
+    /**
+     * Passed with {@link ActionListener#onFailure}.
+     * Indicates that the operation is already in progress
+     * @hide
+     */
+    public static final int IN_PROGRESS                 = 1;
+
+    /**
+     * Passed with {@link ActionListener#onFailure}.
+     * Indicates that the operation failed because the framework is busy and
+     * unable to service the request
+     * @hide
+     */
+    public static final int BUSY                        = 2;
+
+    /** Interface for callback invocation on an application action {@hide} */
+    public interface ActionListener {
+        /** The operation succeeded */
+        public void onSuccess();
+        /**
+         * The operation failed
+         * @param reason The reason for failure could be one of
+         * {@link #ERROR}, {@link #IN_PROGRESS} or {@link #BUSY}
+         */
+        public void onFailure(int reason);
+    }
+
+    /** Interface for callback invocation on a TX packet count poll action {@hide} */
+    public interface TxPacketCountListener {
+        /**
+         * The operation succeeded
+         * @param count TX packet counter
+         */
+        public void onSuccess(int count);
+        /**
+         * The operation failed
+         * @param reason The reason for failure could be one of
+         * {@link #ERROR}, {@link #IN_PROGRESS} or {@link #BUSY}
+         */
+        public void onFailure(int reason);
+    }
+
+    private class ServiceHandler extends Handler {
+        ServiceHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message message) {
+            Object listener = removeListener(message.arg2);
+            switch (message.what) {
+
+		/* ActionListeners grouped together */
+                case EthernetManager.CONNECT_NETWORK_FAILED:
+                case EthernetManager.FORGET_NETWORK_FAILED:
+                case EthernetManager.SAVE_NETWORK_FAILED:
+                case EthernetManager.DISABLE_NETWORK_FAILED:
+                    if (listener != null) {
+                        ((ActionListener) listener).onFailure(message.arg1);
+                    }
+                    break;
+
+                /* ActionListeners grouped together */
+                case EthernetManager.CONNECT_NETWORK_SUCCEEDED:
+                case EthernetManager.FORGET_NETWORK_SUCCEEDED:
+                case EthernetManager.SAVE_NETWORK_SUCCEEDED:
+                case EthernetManager.DISABLE_NETWORK_SUCCEEDED:
+                    if (listener != null) {
+                        ((ActionListener) listener).onSuccess();
+                    }
+                    break;
+
+                default:
+                    //ignore
+                    break;
+            }
+        }
+    }
+
+    private int putListener(Object listener) {
+        if (listener == null) return INVALID_KEY;
+        int key;
+        synchronized (mListenerMapLock) {
+            do {
+                key = mListenerKey++;
+            } while (key == INVALID_KEY);
+            mListenerMap.put(key, listener);
+        }
+        return key;
+    }
+
+    private Object removeListener(int key) {
+        if (key == INVALID_KEY) return null;
+        synchronized (mListenerMapLock) {
+            Object listener = mListenerMap.get(key);
+            mListenerMap.remove(key);
+            return listener;
+        }
+    }
+
+    private void init() {
+        mEthernetServiceMessenger = getEthernetServiceMessenger();
+        if (mEthernetServiceMessenger == null) {
+            mAsyncChannel = null;
+            return;
+        }
+
+        HandlerThread t = new HandlerThread("EthernetManager");
+        t.start();
+        mHandler = new ServiceHandler(t.getLooper());
+        mAsyncChannel.connect(mContext, mHandler, mEthernetServiceMessenger);
+        try {
+            mConnected.await();
+        } catch (InterruptedException e) {
+            Log.e(TAG, "interrupted wait at init");
+        }
+    }
+
+    private void validateChannel() {
+        if (mAsyncChannel == null) throw new IllegalStateException(
+                "No permission to access and change ethernet or a bad initialization");
+    }
+
+    /**
+     * Connect to a network with the given configuration.
+     *
+     * For a new network, this function is used instead of a
+     * sequence of addNetwork(), enableNetwork(), saveConfiguration() and
+     * reconnect()
+     *
+     * @param config the set of variables that describe the configuration,
+     *            contained in a {@link EthernetConfiguration} object.
+     * @param listener for callbacks on success or failure. Can be null.
+     * @throws IllegalStateException if the EthernetManager instance needs to be
+     * initialized again
+     *
+     * @hide
+     */
+    public void connect(EthernetConfiguration config, ActionListener listener) {
+        if (config == null) throw new IllegalArgumentException("config cannot be null");
+        validateChannel();
+        // Use INVALID_NETWORK_ID for arg1 when passing a config object
+        // arg1 is used to pass network id when the network already exists
+        mAsyncChannel.sendMessage(CONNECT_NETWORK, EthernetConfiguration.INVALID_NETWORK_ID,
+                putListener(listener), config);
+    }
+
+    /**
+     * Connect to a network with the given networkId.
+     *
+     * This function is used instead of a enableNetwork(), saveConfiguration() and
+     * reconnect()
+     *
+     * @param networkId the network id identifiying the network in the
+     *                supplicant configuration list
+     * @param listener for callbacks on success or failure. Can be null.
+     * @throws IllegalStateException if the EthernetManager instance needs to be
+     * initialized again
+     * @hide
+     */
+    public void connect(int networkId, ActionListener listener) {
+        if (networkId < 0) throw new IllegalArgumentException("Network id cannot be negative");
+        validateChannel();
+        mAsyncChannel.sendMessage(CONNECT_NETWORK, networkId, putListener(listener));
+    }
+
+    /**
+     * Save the given network in the supplicant config. If the network already
+     * exists, the configuration is updated. A new network is enabled
+     * by default.
+     *
+     * For a new network, this function is used instead of a
+     * sequence of addNetwork(), enableNetwork() and saveConfiguration().
+     *
+     * For an existing network, it accomplishes the task of updateNetwork()
+     * and saveConfiguration()
+     *
+     * @param config the set of variables that describe the configuration,
+     *            contained in a {@link EthernetConfiguration} object.
+     * @param listener for callbacks on success or failure. Can be null.
+     * @throws IllegalStateException if the EthernetManager instance needs to be
+     * initialized again
+     * @hide
+     */
+    public void save(EthernetConfiguration config, ActionListener listener) {
+        if (config == null) throw new IllegalArgumentException("config cannot be null");
+        validateChannel();
+        mAsyncChannel.sendMessage(SAVE_NETWORK, 0, putListener(listener), config);
+    }
+
+    /**
+     * Delete the network in the supplicant config.
+     *
+     * This function is used instead of a sequence of removeNetwork()
+     * and saveConfiguration().
+     *
+     * @param config the set of variables that describe the configuration,
+     *            contained in a {@link EthernetConfiguration} object.
+     * @param listener for callbacks on success or failure. Can be null.
+     * @throws IllegalStateException if the EthernetManager instance needs to be
+     * initialized again
+     * @hide
+     */
+    public void forget(int netId, ActionListener listener) {
+        if (netId < 0) throw new IllegalArgumentException("Network id cannot be negative");
+        validateChannel();
+        mAsyncChannel.sendMessage(FORGET_NETWORK, netId, putListener(listener));
+    }
+
+    /**
+     * Disable network
+     *
+     * @param netId is the network Id
+     * @param listener for callbacks on success or failure. Can be null.
+     * @throws IllegalStateException if the EthernetManager instance needs to be
+     * initialized again
+     * @hide
+     */
+    public void disable(int netId, ActionListener listener) {
+        if (netId < 0) throw new IllegalArgumentException("Network id cannot be negative");
+        validateChannel();
+        mAsyncChannel.sendMessage(DISABLE_NETWORK, netId, putListener(listener));
+    }
+
+    /**
+     * Get a reference to EthernetService handler. This is used by a client to establish
+     * an AsyncChannel communication with EthernetService
+     *
+     * @return Messenger pointing to the EthernetService handler
+     * @hide
+     */
+    public Messenger getEthernetServiceMessenger() {
+        try {
+            return mService.getEthernetServiceMessenger();
+        } catch (RemoteException e) {
+            return null;
+        } catch (SecurityException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Get a reference to EthernetStateMachine handler.
+     * @return Messenger pointing to the EthernetService handler
+     * @hide
+     */
+    public Messenger getEthernetStateMachineMessenger() {
+        try {
+            return mService.getEthernetStateMachineMessenger();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the file in which IP and proxy configuration data is stored
+     * @hide
+     */
+    public String getConfigFile() {
+        try {
+            return mService.getConfigFile();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Allows an application to keep the Ethernet awake at full-speed.
+     * Normally the Ethernet may turn at low speed  when the user has not used
+     * the device in a while.
+     * Acquiring an EthernetLock will keep the link at full speed until the
+     * lock is released.  Multiple applications may hold EthernetLocks, and the
+     * chipset will only be allowed to turn low when no EthernetLocks are held
+     * in any application.
+     * <p>
+     * Before using a EthernetLock, consider carefully if your application
+     * requires Ethernet access.  A program that needs to download large
+     * files should hold an EthernetLock to ensure that the download will
+     * complete, but a program whose network usage is occasional or
+     * low-bandwidth should not hold an EthernetLock to avoid adversely
+     * affecting battery life or consuming too much energy.
+     * <p>
+     * Note that EthernetLocks cannot override the user-level "Ethernet
+     * Enabled" setting.  They simply keep the chipset from turning low-speed
+     * when Ethernet is already on but the device is idle.
+     * <p>
+     * Any application using an EthernetLock must request the
+     * {@code android.permission.WAKE_LOCK} permission in an
+     * {@code &lt;uses-permission&gt;} element of the application's manifest.
+     */
+    public class EthernetLock {
+        private String mTag;
+        private final IBinder mBinder;
+        private int mRefCount;
+        int mLockType;
+        private boolean mRefCounted;
+        private boolean mHeld;
+        private WorkSource mWorkSource;
+
+        private EthernetLock(int lockType, String tag) {
+            mTag = tag;
+            mLockType = lockType;
+            mBinder = new Binder();
+            mRefCount = 0;
+            mRefCounted = true;
+            mHeld = false;
+        }
+
+        /**
+         * Locks the Ethernet chipset on until {@link #release} is called.
+         *
+         * If this EthernetLock is reference-counted, each call to
+	 * {@code acquire} will increment the reference count, and the chipset
+	 * will remain locked as long as the reference count is
+         * above zero.
+         *
+         * If this EthernetLock is not reference-counted, the first call to
+	 * {@code acquire} will lock the chipset, but subsequent calls will be
+	 * ignored.  Only one call to {@link #release} will be required,
+	 * regardless of the number of times that {@code acquire} is called.
+         */
+        public void acquire() {
+            synchronized (mBinder) {
+                if (mRefCounted ? (++mRefCount == 1) : (!mHeld)) {
+                    try {
+                        mService.acquireEthernetLock(mBinder, mLockType, mTag, mWorkSource);
+                        synchronized (EthernetManager.this) {
+                            if (mActiveLockCount >= MAX_ACTIVE_LOCKS) {
+                                mService.releaseEthernetLock(mBinder);
+                                throw new UnsupportedOperationException(
+                                            "Exceeded maximum number of ethernet locks");
+                            }
+                            mActiveLockCount++;
+                        }
+                    } catch (RemoteException ignore) {
+                    }
+                    mHeld = true;
+                }
+            }
+        }
+
+        /**
+         * Unlocks the Ethernet chipset, allowing it to turn low-speed when the
+	 * device is idle.
+         *
+         * If this EthernetLock is reference-counted, each call to
+	 * {@code release} will decrement the reference count, and the chipset
+	 * will be unlocked only when the reference count reaches
+         * zero. If the reference count goes below zero (that is, if
+	 * {@code release} is called a greater number of times than
+	 * {@link #acquire}), an exception is thrown.
+         *
+         * If this EthernetLock is not reference-counted, the first call to
+	 * {@code release} (after the chipset was locked using
+	 * {@link #acquire}) will unlock the chipset, and subsequent
+         * calls will be ignored.
+         */
+        public void release() {
+            synchronized (mBinder) {
+                if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
+                    try {
+                        mService.releaseEthernetLock(mBinder);
+                        synchronized (EthernetManager.this) {
+                            mActiveLockCount--;
+                        }
+                    } catch (RemoteException ignore) {
+                    }
+                    mHeld = false;
+                }
+                if (mRefCount < 0) {
+                    throw new RuntimeException("EthernetLock under-locked " + mTag);
+                }
+            }
+        }
+
+        /**
+         * Controls whether this is a reference-counted or
+	 * non-reference-counted EthernetLock.
+         *
+         * Reference-counted EthernetLocks keep track of the number of calls to
+	 * {@link #acquire} and {@link #release}, and only allow the chipset to
+	 * go low-speed when every call to {@link #acquire}
+         * has been balanced with a call to {@link #release}.
+	 * Non-reference-counted EthernetLocks lock the chipset whenever
+	 * {@link #acquire} is called and it is unlocked, and unlock the
+         * chipset whenever {@link #release} is called and it is locked.
+         *
+         * @param refCounted true if this EthernetLock should keep a
+	 * reference count
+         */
+        public void setReferenceCounted(boolean refCounted) {
+            mRefCounted = refCounted;
+        }
+
+        /**
+         * Checks whether this EthernetLock is currently held.
+         *
+         * @return true if this EthernetLock is held, false otherwise
+         */
+        public boolean isHeld() {
+            synchronized (mBinder) {
+                return mHeld;
+            }
+        }
+
+        public void setWorkSource(WorkSource ws) {
+            synchronized (mBinder) {
+                if (ws != null && ws.size() == 0) {
+                    ws = null;
+                }
+                boolean changed = true;
+                if (ws == null) {
+                    mWorkSource = null;
+                } else if (mWorkSource == null) {
+                    changed = mWorkSource != null;
+                    mWorkSource = new WorkSource(ws);
+                } else {
+                    changed = mWorkSource.diff(ws);
+                    if (changed) {
+                        mWorkSource.set(ws);
+                    }
+                }
+                if (changed && mHeld) {
+                    try {
+                        mService.updateEthernetLockWorkSource(mBinder, mWorkSource);
+                    } catch (RemoteException e) {
+                    }
+                }
+            }
+        }
+
+        public String toString() {
+            String s1, s2, s3;
+            synchronized (mBinder) {
+                s1 = Integer.toHexString(System.identityHashCode(this));
+                s2 = mHeld ? "held; " : "";
+                if (mRefCounted) {
+                    s3 = "refcounted: refcount = " + mRefCount;
+                } else {
+                    s3 = "not refcounted";
+                }
+                return "EthernetLock{ " + s1 + "; " + s2 + s3 + " }";
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            super.finalize();
+            synchronized (mBinder) {
+                if (mHeld) {
+                    try {
+                        mService.releaseEthernetLock(mBinder);
+                        synchronized (EthernetManager.this) {
+                            mActiveLockCount--;
+                        }
+                    } catch (RemoteException ignore) {
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Creates a new EthernetLock.
+     *
+     * @param lockType the type of lock to create.
+     * See {@link #ETHERNET_MODE_FULL}, {@link #ETHERNET_MODE_FULL_HIGH_PERF}
+     * and {@link #ETHERNET_MODE_RESTRICTED_FE} for descriptions of the types
+     * of Ethernet locks.
+     * @param tag a tag for the EthernetLock to identify it in debugging
+     * messages. This string is never shown to the user under normal
+     * conditions, but should be descriptive enough to identify your
+     * application and the specific EthernetLock within it, if it
+     * holds multiple EthernetLocks.
+     *
+     * @return a new, unacquired EthernetLock with the given tag.
+     *
+     * @see EthernetLock
+     */
+    public EthernetLock createEthernetLock(int lockType, String tag) {
+        return new EthernetLock(lockType, tag);
+    }
+
+    /**
+     * Creates a new EthernetLock.
+     *
+     * @param tag a tag for the EthernetLock to identify it in debugging
+     * messages. This string is never shown to the user under normal
+     * conditions, but should be descriptive enough to identify your
+     * application and the specific EthernetLock within it, if it
+     * holds multiple EthernetLocks.
+     *
+     * @return a new, unacquired EthernetLock with the given tag.
+     *
+     * @see EthernetLock
+     */
+    public EthernetLock createEthernetLock(String tag) {
+        return new EthernetLock(ETHERNET_MODE_FULL, tag);
+    }
+
+    /**
+     * Create a new MulticastLock
+     *
+     * @param tag a tag for the MulticastLock to identify it in debugging
+     *            messages.  This string is never shown to the user under
+     *            normal conditions, but should be descriptive enough to
+     *            identify your application and the specific MulticastLock
+     *            within it, if it holds multiple MulticastLocks.
+     *
+     * @return a new, unacquired MulticastLock with the given tag.
+     *
+     * @see MulticastLock
+     */
+    public MulticastLock createMulticastLock(String tag) {
+        return new MulticastLock(tag);
+    }
+
+    /**
+     * Allows an application to receive Ethernet Multicast packets.
+     * Normally the Ethernet stack filters out packets not explicitly
+     * addressed to this device.  Acquring a MulticastLock will
+     * cause the stack to receive packets addressed to multicast
+     * addresses.  Processing these extra packets can cause a noticable
+     * battery drain and should be disabled when not needed.
+     */
+    public class MulticastLock {
+        private String mTag;
+        private final IBinder mBinder;
+        private int mRefCount;
+        private boolean mRefCounted;
+        private boolean mHeld;
+
+        private MulticastLock(String tag) {
+            mTag = tag;
+            mBinder = new Binder();
+            mRefCount = 0;
+            mRefCounted = true;
+            mHeld = false;
+        }
+
+        /**
+         * Locks Ethernet Multicast on until {@link #release} is called.
+         *
+         * If this MulticastLock is reference-counted each call to
+         * {@code acquire} will increment the reference count, and the
+         * ethernet interface will receive multicast packets as long as the
+         * reference count is above zero.
+         *
+         * If this MulticastLock is not reference-counted, the first call to
+         * {@code acquire} will turn on the multicast packets, but subsequent
+         * calls will be ignored.  Only one call to {@link #release} will
+         * be required, regardless of the number of times that {@code acquire}
+         * is called.
+         *
+         * Note that other applications may also lock Ethernet Multicast on.
+         * Only they can relinquish their lock.
+         *
+         * Also note that applications cannot leave Multicast locked on.
+         * When an app exits or crashes, any Multicast locks will be released.
+         */
+        public void acquire() {
+            synchronized (mBinder) {
+                if (mRefCounted ? (++mRefCount == 1) : (!mHeld)) {
+                    try {
+                        mService.acquireMulticastLock(mBinder, mTag);
+                        synchronized (EthernetManager.this) {
+                            if (mActiveLockCount >= MAX_ACTIVE_LOCKS) {
+                                mService.releaseMulticastLock();
+                                throw new UnsupportedOperationException(
+                                        "Exceeded maximum number of ethernet locks");
+                            }
+                            mActiveLockCount++;
+                        }
+                    } catch (RemoteException ignore) {
+                    }
+                    mHeld = true;
+                }
+            }
+        }
+
+        /**
+         * Unlocks Ethernet Multicast, restoring the filter of packets
+         * not addressed specifically to this device and saving power.
+         *
+         * If this MulticastLock is reference-counted, each call to
+         * {@code release} will decrement the reference count, and the
+         * multicast packets will only stop being received when the reference
+         * count reaches zero.  If the reference count goes below zero (that
+         * is, if {@code release} is called a greater number of times than
+         * {@link #acquire}), an exception is thrown.
+         *
+         * If this MulticastLock is not reference-counted, the first call to
+         * {@code release} (after the chipset was multicast locked using
+         * {@link #acquire}) will unlock the multicast, and subsequent calls
+         * will be ignored.
+         *
+         * Note that if any other Ethernet Multicast Locks are still outstanding
+         * this {@code release} call will not have an immediate effect.  Only
+         * when all applications have released all their Multicast Locks will
+         * the Multicast filter be turned back on.
+         *
+         * Also note that when an app exits or crashes all of its Multicast
+         * Locks will be automatically released.
+         */
+        public void release() {
+            synchronized (mBinder) {
+                if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
+                    try {
+                        mService.releaseMulticastLock();
+                        synchronized (EthernetManager.this) {
+                            mActiveLockCount--;
+                        }
+                    } catch (RemoteException ignore) {
+                    }
+                    mHeld = false;
+                }
+                if (mRefCount < 0) {
+                    throw new RuntimeException("MulticastLock under-locked "
+                            + mTag);
+                }
+            }
+        }
+
+        /**
+         * Controls whether this is a reference-counted or non-reference-
+         * counted MulticastLock.
+         *
+         * Reference-counted MulticastLocks keep track of the number of calls
+         * to {@link #acquire} and {@link #release}, and only stop the
+         * reception of multicast packets when every call to {@link #acquire}
+         * has been balanced with a call to {@link #release}.  Non-reference-
+         * counted MulticastLocks allow the reception of multicast packets
+         * whenever {@link #acquire} is called and stop accepting multicast
+         * packets whenever {@link #release} is called.
+         *
+         * @param refCounted true if this MulticastLock should keep a reference
+         * count
+         */
+        public void setReferenceCounted(boolean refCounted) {
+            mRefCounted = refCounted;
+        }
+
+        /**
+         * Checks whether this MulticastLock is currently held.
+         *
+         * @return true if this MulticastLock is held, false otherwise
+         */
+        public boolean isHeld() {
+            synchronized (mBinder) {
+                return mHeld;
+            }
+        }
+
+        public String toString() {
+            String s1, s2, s3;
+            synchronized (mBinder) {
+                s1 = Integer.toHexString(System.identityHashCode(this));
+                s2 = mHeld ? "held; " : "";
+                if (mRefCounted) {
+                    s3 = "refcounted: refcount = " + mRefCount;
+                } else {
+                    s3 = "not refcounted";
+                }
+                return "MulticastLock{ " + s1 + "; " + s2 + s3 + " }";
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            super.finalize();
+            setReferenceCounted(false);
+            release();
+        }
+    }
+
+    /**
+     * Check multicast filter status.
+     *
+     * @return true if multicast packets are allowed.
+     *
+     * @hide pending API council approval
+     */
+    public boolean isMulticastEnabled() {
+        try {
+            return mService.isMulticastEnabled();
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Initialize the multicast filtering to 'on'
+     * @hide no intent to publish
+     */
+    public boolean initializeMulticastFiltering() {
+        try {
+            mService.initializeMulticastFiltering();
+            return true;
+        } catch (RemoteException e) {
+             return false;
+        }
+    }
+
+    /** @hide */
+    public void captivePortalCheckComplete() {
+        try {
+            mService.captivePortalCheckComplete();
+        } catch (RemoteException e) {}
+    }
+
+    protected void finalize() throws Throwable {
+        try {
+            if (mHandler != null && mHandler.getLooper() != null) {
+                mHandler.getLooper().quit();
+            }
+        } finally {
+            super.finalize();
+        }
+    }
+}
diff --git a/ethernet/java/android/net/ethernet/EthernetMonitor.java b/ethernet/java/android/net/ethernet/EthernetMonitor.java
new file mode 100644
index 0000000..3f9c2af
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/EthernetMonitor.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.ethernet;
+
+import android.net.NetworkInfo;
+
+import android.util.Config;
+import android.util.Slog;
+import java.util.StringTokenizer;
+
+import com.android.internal.util.Protocol;
+import com.android.internal.util.StateMachine;
+
+import java.util.List;
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+
+/**
+ * Listens for events from kernel, and passes them on
+ * to the {@link StateMachine} for handling. Runs in its own thread.
+ *
+ * @hide
+ */
+public class EthernetMonitor {
+
+    private static final String TAG = "EthernetMonitor";
+
+    /** Internal events */
+    private static final int EVENT_UNKNOWN = 0;
+    private static final int EVENT_PHY_UP = 1;
+    private static final int EVENT_PHY_DOWN = 2;
+    private static final int EVENT_CONNECTED = 3;
+    private static final int EVENT_DISCONNECTED = 4;
+
+    private static final String EVENT_PHY_UP_STR = "PHY_UP";
+    private static final String EVENT_PHY_DOWN_STR = "PHY_DOWN";
+    private static final String EVENT_CONNECTED_STR = "CONNECTED";
+    private static final String EVENT_DISCONNECTED_STR = "DISCONNECTED";
+
+    private final StateMachine mStateMachine;
+    private final EthernetNative mEthernetNative;
+
+    /* Kernel events reported to a state machine */
+    private static final int BASE = Protocol.BASE_ETHERNET_MONITOR;
+
+    /* Network connection completed */
+    public static final int NETWORK_CONNECTION_EVENT             = BASE + 1;
+    /* Network disconnection completed */
+    public static final int NETWORK_DISCONNECTION_EVENT          = BASE + 2;
+
+    public EthernetMonitor(StateMachine ethernetStateMachine, EthernetNative ethernetNative) {
+	mStateMachine = ethernetStateMachine;
+	mEthernetNative = ethernetNative;
+    }
+
+    public void startMonitoring() {
+        new MonitorThread().start();
+    }
+
+    class MonitorThread extends Thread {
+        public MonitorThread() {
+            super("EthernetMonitor");
+        }
+
+        public void run() {
+
+            //noinspection InfiniteLoopStatement
+            for (;;) {
+                Log.d(TAG, "Poll Ethernet netlink events");
+
+                String eventStr = mEthernetNative.waitForEvent();
+
+                if (eventStr == null) {
+                    continue;
+                }
+
+                Log.d(TAG, "Event [" + eventStr + "]");
+
+		if (EVENT_PHY_UP_STR.isEqual(eventStr)) {
+		    mStateMachine.sendMessage(EVENT_PHY_UP);
+                    //mTracker.notifyPhyConnected();
+		}
+		else if (EVENT_PHY_DOWN_STR.isEqual(eventStr)) {
+		    mStateMachine.sendMessage(EVENT_PHY_DOWN);
+                    //mTracker.notifyPhyDisconnected();
+		}
+		else if (EVENT_CONNECTED_STR.isEqual(eventStr)) {
+		    mStateMachine.sendMessage(EVENT_CONNECTED);
+                    //mTracker.notifyStateChange(NetworkInfo.DetailedState.CONNECTED);
+		}
+		else if (EVENT_DISCONNECTED_STR.isEqual(eventStr)) {
+		    mStateMachine.sendMessage(EVENT_DISCONNECTED);
+                    //mTracker.notifyStateChange(NetworkInfo.DetailedState.DISCONNECTED);
+		} else {
+                    //mTracker.notifyStateChange(NetworkInfo.DetailedState.FAILED);
+		}
+            }
+        }
+    }
+}
diff --git a/ethernet/java/android/net/ethernet/EthernetNative.java b/ethernet/java/android/net/ethernet/EthernetNative.java
new file mode 100644
index 0000000..a3a8c6b
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/EthernetNative.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.ethernet;
+
+/**
+ * Native calls for sending requests to the kernel
+ *
+ * waitForEvent() is called on the monitor thread for events. All other methods
+ * must be serialized from the framework.
+ *
+ * {@hide}
+ */
+public class EthernetNative {
+
+    private static final boolean DBG = false;
+    private final String mTAG;
+
+    String mInterface = "";
+
+    public native static boolean loadDriver();
+
+    public native static boolean isDriverLoaded();
+
+    public native static boolean unloadDriver();
+
+    public native static String getMacAddress(String iface);
+
+    public native static boolean initEvent();
+
+    public native static boolean shutdownEvent();
+
+    public native static int initEthernetNative(String iface);
+
+    public native static String waitForEvent(String iface);
+
+    public EthernetNative(String iface) {
+        mInterface = iface;
+        mTAG = "EthernetNative-" + iface;
+    }
+
+    public String getMacAddress() {
+        return getMacAddress(mInterface);
+    }
+
+    public String waitForEvent() {
+        return waitForEvent(mInterface);
+    }
+
+}
diff --git a/ethernet/java/android/net/ethernet/EthernetStateMachine.java b/ethernet/java/android/net/ethernet/EthernetStateMachine.java
new file mode 100644
index 0000000..144974b
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/EthernetStateMachine.java
@@ -0,0 +1,1678 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.ethernet;
+
+import static android.net.ethernet.EthernetManager.ETHERNET_STATE_DISABLED;
+import static android.net.ethernet.EthernetManager.ETHERNET_STATE_DISABLING;
+import static android.net.ethernet.EthernetManager.ETHERNET_STATE_ENABLED;
+import static android.net.ethernet.EthernetManager.ETHERNET_STATE_ENABLING;
+import static android.net.ethernet.EthernetManager.ETHERNET_STATE_UNKNOWN;
+
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.app.backup.IBackupManager;
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.database.ContentObserver;
+import android.net.ConnectivityManager;
+import android.net.DhcpInfo;
+import android.net.DhcpInfoInternal;
+import android.net.DhcpStateMachine;
+import android.net.InterfaceConfiguration;
+import android.net.LinkAddress;
+import android.net.LinkProperties;
+import android.net.NetworkInfo;
+import android.net.NetworkInfo.DetailedState;
+import android.net.NetworkUtils;
+import android.os.Binder;
+import android.os.IBinder;
+import android.os.INetworkManagementService;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.PowerManager;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemClock;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.os.WorkSource;
+import android.provider.Settings;
+import android.util.EventLog;
+import android.util.Log;
+import android.util.LruCache;
+
+import com.android.internal.R;
+import com.android.internal.app.IBatteryStats;
+import com.android.internal.util.AsyncChannel;
+import com.android.internal.util.Protocol;
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.regex.Pattern;
+
+/**
+ * Track the state of Ethernet connectivity. All event handling is done here,
+ * and all changes in connectivity state are initiated here.
+ *
+ * @hide
+ */
+public class EthernetStateMachine extends StateMachine {
+
+    private static final String TAG = "EthernetStateMachine";
+    private static final String NETWORKTYPE = "ETHERNET";
+    private static final boolean DBG = false;
+
+    private EthernetMonitor mEthernetMonitor;
+    private EthernetNative mEthernetNative;
+    private EthernetConfigStore mEthernetConfigStore;
+    private INetworkManagementService mNwService;
+    private ConnectivityManager mCm;
+
+    private boolean mTemporarilyDisconnectEthernet = false;
+    private final String mPrimaryDeviceType;
+
+    private String mInterfaceName;
+    /* Tethering interface could be seperate from lan interface */
+    private String mTetherInterfaceName;
+
+    private int mLastNetworkId;
+    private int mReconnectCount = 0;
+
+    /* Tracks if state machine has received any screen state change broadcast yet.
+     * We can miss one of these at boot.
+     */
+    private AtomicBoolean mScreenBroadcastReceived = new AtomicBoolean(false);
+
+    private PowerManager.WakeLock mSuspendWakeLock;
+
+    /**
+     * Tether state change notification time out
+     */
+    private static final int TETHER_NOTIFICATION_TIME_OUT_MSECS = 5000;
+
+    /* Tracks sequence number on a tether notification time out */
+    private int mTetherToken = 0;
+
+    /**
+     * Driver start time out.
+     */
+    private static final int DRIVER_START_TIME_OUT_MSECS = 10000;
+
+    /* Tracks sequence number on a driver time out */
+    private int mDriverStartToken = 0;
+
+    private LinkProperties mLinkProperties;
+
+    // Wakelock held during ethernet start/stop and driver load/unload
+    private PowerManager.WakeLock mWakeLock;
+
+    private Context mContext;
+
+    private DhcpInfoInternal mDhcpInfoInternal;
+    private EthernetInfo mEthernetInfo;
+    private NetworkInfo mNetworkInfo;
+    private DhcpStateMachine mDhcpStateMachine;
+
+    private AlarmManager mAlarmManager;
+    private PendingIntent mDriverStopIntent;
+
+    /* Tracks if we are filtering Multicast v4 packets. Default is to filter. */
+    private AtomicBoolean mFilteringMulticastV4Packets = new AtomicBoolean(true);
+
+    // Channel for sending replies.
+    private AsyncChannel mReplyChannel = new AsyncChannel();
+
+    // Event log tags (must be in sync with event-log-tags)
+    private static final int EVENTLOG_ETHERNET_STATE_CHANGED        = 50031;
+    private static final int EVENTLOG_ETHERNET_EVENT_HANDLED        = 50032;
+
+    /* The base for ethernet message types */
+    static final int BASE = Protocol.BASE_ETHERNET;
+
+    /* Load the driver */
+    static final int CMD_LOAD_DRIVER                      = BASE + 1;
+    /* Unload the driver */
+    static final int CMD_UNLOAD_DRIVER                    = BASE + 2;
+    /* Indicates driver load succeeded */
+    static final int CMD_LOAD_DRIVER_SUCCESS              = BASE + 3;
+    /* Indicates driver load failed */
+    static final int CMD_LOAD_DRIVER_FAILURE              = BASE + 4;
+    /* Indicates driver unload succeeded */
+    static final int CMD_UNLOAD_DRIVER_SUCCESS            = BASE + 5;
+    /* Indicates driver unload failed */
+    static final int CMD_UNLOAD_DRIVER_FAILURE            = BASE + 6;
+
+    /* Indicates Static IP succeded */
+    static final int CMD_STATIC_IP_SUCCESS                = BASE + 11;
+    /* Indicates Static IP failed */
+    static final int CMD_STATIC_IP_FAILURE                = BASE + 12;
+    /* Ready to switch to network as default */
+    static final int CMD_CAPTIVE_CHECK_COMPLETE           = BASE + 13;
+    /* Invoked when getting a tether state change notification */
+    static final int CMD_TETHER_STATE_CHANGE              = BASE + 14;
+    /* A delayed message sent to indicate tether state change failed to arrive */
+    static final int CMD_TETHER_NOTIFICATION_TIMED_OUT    = BASE + 15;
+
+    /* Add/update a network configuration */
+    static final int CMD_ADD_OR_UPDATE_NETWORK            = BASE + 21;
+    /* Delete a network */
+    static final int CMD_REMOVE_NETWORK                   = BASE + 22;
+    /* Enable a network. The device will attempt a connection to the given network. */
+    static final int CMD_ENABLE_NETWORK                   = BASE + 23;
+    /* Enable all networks */
+    static final int CMD_ENABLE_ALL_NETWORKS              = BASE + 24;
+    /* Save configuration */
+    static final int CMD_SAVE_CONFIG                      = BASE + 25;
+    /* Get configured networks*/
+    static final int CMD_GET_CONFIGURED_NETWORKS          = BASE + 26;
+
+    /* Disconnect from a network */
+    static final int CMD_DISCONNECT                       = BASE + 31;
+    /* Reconnect to a network */
+    static final int CMD_RECONNECT                        = BASE + 32;
+
+/* Controls suspend mode optimizations
+     *
+     * When high perf mode is enabled, suspend mode optimizations are disabled
+     *
+     * When high perf mode is disabled, suspend mode optimizations are enabled
+     *
+     * Suspend mode optimizations includes packet filtering.
+     */
+    static final int CMD_SET_HIGH_PERF_MODE               = BASE + 41;
+    /* Set up packet filtering */
+    static final int CMD_START_PACKET_FILTERING           = BASE + 42;
+    /* Clear packet filter */
+    static final int CMD_STOP_PACKET_FILTERING            = BASE + 43;
+
+    /* arg1 values to CMD_STOP_PACKET_FILTERING and CMD_START_PACKET_FILTERING */
+    static final int MULTICAST_V6  = 1;
+    static final int MULTICAST_V4  = 0;
+
+    private static final int SUCCESS = 1;
+    private static final int FAILURE = -1;
+
+    /* Phone in emergency call back mode */
+    private static final int IN_ECM_STATE = 1;
+    private static final int NOT_IN_ECM_STATE = 0;
+
+    /**
+     * The maximum number of times we will retry a connection
+     * for which we have failed in acquiring an IP address from DHCP. A value of
+     * N means that we will make N+1 connection attempts in all.
+     * <p>
+     * See {@link Settings.Secure#ETHERNET_MAX_DHCP_RETRY_COUNT}. This is the default
+     * value if a Settings value is not present.
+     */
+    private static final int DEFAULT_MAX_DHCP_RETRIES = 9;
+
+    /* Tracks if suspend optimizations need to be disabled by DHCP,
+     * screen or due to high perf mode.
+     * When any of them needs to disable it, we keep the suspend optimizations
+     * disabled
+     */
+    private int mSuspendOptNeedsDisabled = 0;
+
+    private static final int SUSPEND_DUE_TO_DHCP       = 1;
+    private static final int SUSPEND_DUE_TO_HIGH_PERF  = 1<<1;
+    private static final int SUSPEND_DUE_TO_SCREEN     = 1<<2;
+
+    /* Tracks if user has enabled suspend optimizations through settings */
+    private AtomicBoolean mUserWantsSuspendOpt = new AtomicBoolean(true);
+
+    /**
+     * Minimum time interval between enabling all networks.
+     * A device can end up repeatedly connecting to a bad network on screen on/off toggle
+     * due to enabling every time. We add a threshold to avoid this.
+     */
+    private static final int MIN_INTERVAL_ENABLE_ALL_NETWORKS_MS = 10 * 60 * 1000; /* 10 minutes */
+    private long mLastEnableAllNetworksTime;
+
+    /* Default parent state */
+    private State mDefaultState = new DefaultState();
+    /* Temporary initial state */
+    private State mInitialState = new InitialState();
+
+    /* Unloading the driver */
+    private State mDriverUnloadingState = new DriverUnloadingState();
+    /* Loading the driver */
+    private State mDriverUnloadedState = new DriverUnloadedState();
+    /* Driver load/unload failed */
+    private State mDriverFailedState = new DriverFailedState();
+    /* Driver loading */
+    private State mDriverLoadingState = new DriverLoadingState();
+    /* Driver loaded */
+    private State mDriverLoadedState = new DriverLoadedState();
+
+    /* Connecting to network */
+    private State mConnectModeState = new ConnectModeState();
+    /* Connected at 802.11 (L2) level */
+    private State mL2ConnectedState = new L2ConnectedState();
+    /* fetching IP after connection to network */
+    private State mObtainingIpState = new ObtainingIpState();
+    /* Waiting for captive portal check to be complete */
+    private State mCaptivePortalCheckState = new CaptivePortalCheckState();
+    /* Connected with IP addr */
+    private State mConnectedState = new ConnectedState();
+    /* disconnect issued, waiting for network disconnect confirmation */
+    private State mDisconnectingState = new DisconnectingState();
+    /* Network is not connected */
+    private State mDisconnectedState = new DisconnectedState();
+
+    /* waiting for tether notification */
+    private State mTetheringState = new TetheringState();
+    /* we are tethered through connectivity service */
+    private State mTetheredState = new TetheredState();
+
+    private class TetherStateChange {
+        ArrayList<String> available;
+        ArrayList<String> active;
+        TetherStateChange(ArrayList<String> av, ArrayList<String> ac) {
+            available = av;
+            active = ac;
+        }
+    }
+
+    /**
+     * One of  {@link EthernetManager#ETHERNET_STATE_DISABLED},
+     *         {@link EthernetManager#ETHERNET_STATE_DISABLING},
+     *         {@link EthernetManager#ETHERNET_STATE_ENABLED},
+     *         {@link EthernetManager#ETHERNET_STATE_ENABLING},
+     *         {@link EthernetManager#ETHERNET_STATE_UNKNOWN}
+     *
+     */
+    private final AtomicInteger mEthernetState = new AtomicInteger(ETHERNET_STATE_DISABLED);
+
+    private final AtomicInteger mLastEnableUid = new AtomicInteger(Process.myUid());
+
+    /**
+     * Keep track of whether ETHERNET is running.
+     */
+    private boolean mIsRunning = false;
+
+    /**
+     * Keep track of whether we last told the battery stats we had started.
+     */
+    private boolean mReportedRunning = false;
+
+    /**
+     * Most recently set source of starting ETHERNET.
+     */
+    private final WorkSource mRunningEthernetUids = new WorkSource();
+
+    /**
+     * The last reported UIDs that were responsible for starting ETHERNET.
+     */
+    private final WorkSource mLastRunningEthernetUids = new WorkSource();
+
+    private final IBatteryStats mBatteryStats;
+
+    public EthernetStateMachine(Context context, String lanInterface) {
+        super(TAG);
+
+        mContext = context;
+        mInterfaceName = lanInterface;
+
+        mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_ETHERNET, 0, NETWORKTYPE, "");
+        mBatteryStats = IBatteryStats.Stub.asInterface(ServiceManager.getService("batteryinfo"));
+
+        IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
+        mNwService = INetworkManagementService.Stub.asInterface(b);
+
+        mEthernetNative = new EthernetNative(mInterfaceName);
+        mEthernetConfigStore = new EthernetConfigStore(context, mEthernetNative);
+        mEthernetMonitor = new EthernetMonitor(this, mEthernetNative);
+        mDhcpInfoInternal = new DhcpInfoInternal();
+        mEthernetInfo = new EthernetInfo();
+        mLinkProperties = new LinkProperties();
+
+        mNetworkInfo.setIsAvailable(false);
+        mLinkProperties.clear();
+        mLastNetworkId = EthernetConfiguration.INVALID_NETWORK_ID;
+
+        mAlarmManager = (AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
+
+        mUserWantsSuspendOpt.set(Settings.Global.getInt(mContext.getContentResolver(),
+                    Settings.Global.ETHERNET_SUSPEND_OPTIMIZATIONS_ENABLED, 1) == 1);
+
+        mContext.registerReceiver(
+            new BroadcastReceiver() {
+                @Override
+                public void onReceive(Context context, Intent intent) {
+                    ArrayList<String> available = intent.getStringArrayListExtra(
+                            ConnectivityManager.EXTRA_AVAILABLE_TETHER);
+                    ArrayList<String> active = intent.getStringArrayListExtra(
+                            ConnectivityManager.EXTRA_ACTIVE_TETHER);
+                    sendMessage(CMD_TETHER_STATE_CHANGE, new TetherStateChange(available, active));
+                }
+            },new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
+
+        IntentFilter screenFilter = new IntentFilter();
+        screenFilter.addAction(Intent.ACTION_SCREEN_ON);
+        screenFilter.addAction(Intent.ACTION_SCREEN_OFF);
+        BroadcastReceiver screenReceiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                String action = intent.getAction();
+
+                if (action.equals(Intent.ACTION_SCREEN_ON)) {
+                    handleScreenStateChanged(true);
+                } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
+                    handleScreenStateChanged(false);
+                }
+            }
+        };
+        mContext.registerReceiver(screenReceiver, screenFilter);
+
+        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(
+                Settings.Global.ETHERNET_SUSPEND_OPTIMIZATIONS_ENABLED), false,
+                new ContentObserver(getHandler()) {
+                    @Override
+                    public void onChange(boolean selfChange) {
+                        mUserWantsSuspendOpt.set(Settings.Global.getInt(mContext.getContentResolver(),
+                                Settings.Global.ETHERNET_SUSPEND_OPTIMIZATIONS_ENABLED, 1) == 1);
+                    }
+                });
+
+        PowerManager powerManager = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
+
+        mSuspendWakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "EthernetSuspend");
+        mSuspendWakeLock.setReferenceCounted(false);
+
+        addState(mDefaultState);
+            addState(mInitialState, mDefaultState);
+            addState(mDriverUnloadingState, mDefaultState);
+            addState(mDriverUnloadedState, mDefaultState);
+                addState(mDriverFailedState, mDriverUnloadedState);
+            addState(mDriverLoadingState, mDefaultState);
+            addState(mDriverLoadedState, mDefaultState);
+                addState(mConnectModeState, mDdefaultState);
+                    addState(mL2ConnectedState, mConnectModeState);
+                        addState(mObtainingIpState, mL2ConnectedState);
+                        addState(mCaptivePortalCheckState, mL2ConnectedState);
+                        addState(mConnectedState, mL2ConnectedState);
+                    addState(mDisconnectingState, mConnectModeState);
+                    addState(mDisconnectedState, mConnectModeState);
+            addState(mTetheringState, mDefaultState);
+            addState(mTetheredState, mDefaultState);
+
+        setInitialState(mInitialState);
+
+        setLogRecSize(100);
+        if (DBG) setDbg(true);
+
+        //start the state machine
+        start();
+    }
+
+    /*********************************************************
+     * Methods exposed for public use
+     ********************************************************/
+
+    public Messenger getMessenger() {
+        return new Messenger(getHandler());
+    }
+
+    /**
+     * TODO: doc
+     */
+    public void setEthernetEnabled(boolean enable) {
+        mLastEnableUid.set(Binder.getCallingUid());
+        if (enable) {
+            /* Argument is the state that is entered prior to load */
+            sendMessage(obtainMessage(CMD_LOAD_DRIVER, ETHERNET_STATE_ENABLING, 0));
+        } else {
+            /* Argument is the state that is entered upon success */
+            sendMessage(obtainMessage(CMD_UNLOAD_DRIVER, ETHERNET_STATE_DISABLED, 0));
+        }
+    }
+
+    /**
+     * TODO: doc
+     */
+    public int syncGetEthernetState() {
+        return mEthernetState.get();
+    }
+
+    /**
+     * TODO: doc
+     */
+    public String syncGetEthernetStateByName() {
+        switch (mEthernetState.get()) {
+            case ETHERNET_STATE_DISABLING:
+                return "disabling";
+            case ETHERNET_STATE_DISABLED:
+                return "disabled";
+            case ETHERNET_STATE_ENABLING:
+                return "enabling";
+            case ETHERNET_STATE_ENABLED:
+                return "enabled";
+            case ETHERNET_STATE_UNKNOWN:
+                return "unknown state";
+            default:
+                return "[invalid state]";
+        }
+    }
+
+    /**
+     * Get status information for the current connection, if any.
+     * @return a {@link EthernetInfo} object containing information about the current connection
+     *
+     */
+    public EthernetInfo syncRequestConnectionInfo() {
+        return mEthernetInfo;
+    }
+
+    public DhcpInfo syncGetDhcpInfo() {
+        synchronized (mDhcpInfoInternal) {
+            return mDhcpInfoInternal.makeDhcpInfo();
+        }
+    }
+
+    public void captivePortalCheckComplete() {
+        sendMessage(obtainMessage(CMD_CAPTIVE_CHECK_COMPLETE));
+    }
+
+    /**
+     * Disconnect from link
+     */
+    public void disconnectCommand() {
+        sendMessage(CMD_DISCONNECT);
+    }
+
+    /**
+     * Initiate a reconnection
+     */
+    public void reconnectCommand() {
+        sendMessage(CMD_RECONNECT);
+    }
+
+    /**
+     * Add a network synchronously
+     *
+     * @return network id of the new network
+     */
+    public int syncAddOrUpdateNetwork(AsyncChannel channel, EthernetConfiguration config) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_ADD_OR_UPDATE_NETWORK, config);
+        int result = resultMsg.arg1;
+        resultMsg.recycle();
+        return result;
+    }
+
+    public List<EthernetConfiguration> syncGetConfiguredNetworks(AsyncChannel channel) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_GET_CONFIGURED_NETWORKS);
+        List<EthernetConfiguration> result = (List<EthernetConfiguration>) resultMsg.obj;
+        resultMsg.recycle();
+        return result;
+    }
+
+    /**
+     * Delete a network
+     *
+     * @param networkId id of the network to be removed
+     */
+    public boolean syncRemoveNetwork(AsyncChannel channel, int networkId) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_REMOVE_NETWORK, networkId);
+        boolean result = (resultMsg.arg1 != FAILURE);
+        resultMsg.recycle();
+        return result;
+    }
+
+    /**
+     * Enable a network
+     *
+     * @param netId network id of the network
+     * @param disableOthers true, if all other networks have to be disabled
+     * @return {@code true} if the operation succeeds, {@code false} otherwise
+     */
+    public boolean syncEnableNetwork(AsyncChannel channel, int netId, boolean disableOthers) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_ENABLE_NETWORK, netId,
+                disableOthers ? 1 : 0);
+        boolean result = (resultMsg.arg1 != FAILURE);
+        resultMsg.recycle();
+        return result;
+    }
+
+    /**
+     * Disable a network
+     *
+     * @param netId network id of the network
+     * @return {@code true} if the operation succeeds, {@code false} otherwise
+     */
+    public boolean syncDisableNetwork(AsyncChannel channel, int netId) {
+        Message resultMsg = channel.sendMessageSynchronously(EthernetManager.DISABLE_NETWORK, netId);
+        boolean result = (resultMsg.arg1 != EthernetManager.DISABLE_NETWORK_FAILED);
+        resultMsg.recycle();
+        return result;
+    }
+
+    public void enableAllNetworks() {
+        sendMessage(CMD_ENABLE_ALL_NETWORKS);
+    }
+
+    /**
+     * Start filtering Multicast v4 packets
+     */
+    public void startFilteringMulticastV4Packets() {
+        mFilteringMulticastV4Packets.set(true);
+        sendMessage(obtainMessage(CMD_START_PACKET_FILTERING, MULTICAST_V4, 0));
+    }
+
+    /**
+     * Stop filtering Multicast v4 packets
+     */
+    public void stopFilteringMulticastV4Packets() {
+        mFilteringMulticastV4Packets.set(false);
+        sendMessage(obtainMessage(CMD_STOP_PACKET_FILTERING, MULTICAST_V4, 0));
+    }
+
+    /**
+     * Start filtering Multicast v4 packets
+     */
+    public void startFilteringMulticastV6Packets() {
+        sendMessage(obtainMessage(CMD_START_PACKET_FILTERING, MULTICAST_V6, 0));
+    }
+
+    /**
+     * Stop filtering Multicast v4 packets
+     */
+    public void stopFilteringMulticastV6Packets() {
+        sendMessage(obtainMessage(CMD_STOP_PACKET_FILTERING, MULTICAST_V6, 0));
+    }
+
+    /**
+     * Returns the ethernet configuration file
+     */
+    public String getConfigFile() {
+        return mEthernetConfigStore.getConfigFile();
+    }
+
+    /**
+     * Save configuration
+     *
+     * @return {@code true} if the operation succeeds, {@code false} otherwise
+     *
+     * TODO: deprecate this
+     */
+    public boolean syncSaveConfig(AsyncChannel channel) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_SAVE_CONFIG);
+        boolean result = (resultMsg.arg1 != FAILURE);
+        resultMsg.recycle();
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        String LS = System.getProperty("line.separator");
+        sb.append("current HSM state: ").append(getCurrentState().getName()).append(LS);
+        sb.append("mLinkProperties ").append(mLinkProperties).append(LS);
+        sb.append("mEthernetInfo ").append(mEthernetInfo).append(LS);
+        sb.append("mDhcpInfoInternal ").append(mDhcpInfoInternal).append(LS);
+        sb.append("mNetworkInfo ").append(mNetworkInfo).append(LS);
+        sb.append("mLastNetworkId ").append(mLastNetworkId).append(LS);
+        sb.append("mReconnectCount ").append(mReconnectCount).append(LS);
+        sb.append("mUserWantsSuspendOpt ").append(mUserWantsSuspendOpt).append(LS);
+        sb.append("mSuspendOptNeedsDisabled ").append(mSuspendOptNeedsDisabled).append(LS);
+
+        sb.append(mEthernetConfigStore.dump());
+        return sb.toString();
+    }
+
+    @Override
+    protected boolean recordLogRec(Message msg) {
+        //Ignore screen on/off & common messages when driver has started
+        if (getCurrentState() == mConnectedState || getCurrentState() == mDisconnectedState) {
+            switch (msg.what) {
+                case CMD_LOAD_DRIVER:
+	        case CMD_SET_HIGH_PERF_MODE:
+                case CMD_SET_SUSPEND_OPT_ENABLED:
+                case CMD_ENABLE_ALL_NETWORKS:
+                return false;
+            }
+        }
+
+	return true;
+    }
+
+    /*********************************************************
+     * Internal private functions
+     ********************************************************/
+
+    private void handleScreenStateChanged(boolean screenOn) {
+        if (DBG) log("handleScreenStateChanged: " + screenOn);
+        if (screenOn) enableAllNetworks();
+        if (mUserWantsSuspendOpt.get()) {
+            if (screenOn) {
+                sendMessage(obtainMessage(CMD_SET_SUSPEND_OPT_ENABLED, 0, 0));
+            } else {
+                //Allow 2s for suspend optimizations to be set
+                mSuspendWakeLock.acquire(2000);
+                sendMessage(obtainMessage(CMD_SET_SUSPEND_OPT_ENABLED, 1, 0));
+            }
+        }
+        mScreenBroadcastReceived.set(true);
+    }
+
+    private void checkAndSetConnectivityInstance() {
+        if (mCm == null) {
+            mCm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+        }
+    }
+
+    private boolean startTethering(ArrayList<String> available) {
+
+        checkAndSetConnectivityInstance();
+
+        String[] ethernetRegexs = mCm.getTetherableEthernetRegexs();
+
+        for (String intf : available) {
+            for (String regex : ethernetRegexs) {
+                if (intf.matches(regex)) {
+
+                    InterfaceConfiguration ifcg = null;
+                    try {
+                        ifcg = mNwService.getInterfaceConfig(intf);
+                        if (ifcg != null) {
+                            /* IP/netmask: 192.168.49.1/255.255.255.0 */
+                            ifcg.setLinkAddress(new LinkAddress(
+                                    NetworkUtils.numericToInetAddress("192.168.49.1"), 24));
+                            ifcg.setInterfaceUp();
+
+                            mNwService.setInterfaceConfig(intf, ifcg);
+                        }
+                    } catch (Exception e) {
+                        loge("Error configuring interface " + intf + ", :" + e);
+                        return false;
+                    }
+
+                    if(mCm.tether(intf) != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
+                        loge("Error tethering on " + intf);
+                        return false;
+                    }
+                    mTetherInterfaceName = intf;
+                    return true;
+                }
+            }
+        }
+        // We found no interfaces to tether
+        return false;
+    }
+
+    private void stopTethering() {
+
+        checkAndSetConnectivityInstance();
+
+        /* Clear the interface config to allow dhcp correctly configure new
+           ip settings */
+        InterfaceConfiguration ifcg = null;
+        try {
+            ifcg = mNwService.getInterfaceConfig(mTetherInterfaceName);
+            if (ifcg != null) {
+                ifcg.setLinkAddress(
+                        new LinkAddress(NetworkUtils.numericToInetAddress("0.0.0.0"), 0));
+                mNwService.setInterfaceConfig(mTetherInterfaceName, ifcg);
+            }
+        } catch (Exception e) {
+            loge("Error resetting interface " + mTetherInterfaceName + ", :" + e);
+        }
+
+        if (mCm.untether(mTetherInterfaceName) != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
+            loge("Untether initiate failed!");
+        }
+    }
+
+    private boolean isEthernetTethered(ArrayList<String> active) {
+
+        checkAndSetConnectivityInstance();
+
+        String[] ethernetRegexs = mCm.getTetherableEthernetRegexs();
+        for (String intf : active) {
+            for (String regex : ethernetRegexs) {
+                if (intf.matches(regex)) {
+                    return true;
+                }
+            }
+        }
+        // We found no interfaces that are tethered
+        return false;
+    }
+
+    private void setSuspendOptimizationsNative(int reason, boolean enabled) {
+        if (DBG) log("setSuspendOptimizationsNative: " + reason + " " + enabled);
+        if (enabled) {
+            mSuspendOptNeedsDisabled &= ~reason;
+            /* None of dhcp, screen or highperf need it disabled and user wants it enabled */
+            if (mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get()) {
+                mEthernetNative.setSuspendOptimizations(true);
+            }
+        } else {
+            mSuspendOptNeedsDisabled |= reason;
+            mEthernetNative.setSuspendOptimizations(false);
+        }
+    }
+
+    private void setSuspendOptimizations(int reason, boolean enabled) {
+        if (DBG) log("setSuspendOptimizations: " + reason + " " + enabled);
+        if (enabled) {
+            mSuspendOptNeedsDisabled &= ~reason;
+        } else {
+            mSuspendOptNeedsDisabled |= reason;
+        }
+        if (DBG) log("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
+    }
+
+    private void setEthernetState(int ethernetState) {
+        final int previousEthernetState = mEthernetState.get();
+
+        try {
+            if (ethernetState == ETHERNET_STATE_ENABLED) {
+                mBatteryStats.noteEthernetOn();
+            } else if (ethernetState == ETHERNET_STATE_DISABLED) {
+                mBatteryStats.noteEthernetOff();
+            }
+        } catch (RemoteException e) {
+            loge("Failed to note battery stats in ethernet");
+        }
+
+        mEthernetState.set(ethernetState);
+
+        if (DBG) log("setEthernetState: " + syncGetEthernetStateByName());
+
+        final Intent intent = new Intent(EthernetManager.ETHERNET_STATE_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(EthernetManager.EXTRA_ETHERNET_STATE, ethernetState);
+        intent.putExtra(EthernetManager.EXTRA_PREVIOUS_ETHERNET_STATE, previousEthernetState);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void configureLinkProperties() {
+        if (mEthernetConfigStore.isUsingStaticIp(mLastNetworkId)) {
+            mLinkProperties = mEthernetConfigStore.getLinkProperties(mLastNetworkId);
+        } else {
+            synchronized (mDhcpInfoInternal) {
+                mLinkProperties = mDhcpInfoInternal.makeLinkProperties();
+            }
+            mLinkProperties.setHttpProxy(mEthernetConfigStore.getProxyProperties(mLastNetworkId));
+        }
+        mLinkProperties.setInterfaceName(mInterfaceName);
+        if (DBG) {
+            log("netId=" + mLastNetworkId  + " Link configured: " +
+                    mLinkProperties.toString());
+        }
+    }
+
+    private int getMaxDhcpRetries() {
+        return Settings.Global.getInt(mContext.getContentResolver(),
+                                      Settings.Global.ETHERNET_MAX_DHCP_RETRY_COUNT,
+                                      DEFAULT_MAX_DHCP_RETRIES);
+    }
+
+    private void sendNetworkStateChangeBroadcast() {
+        Intent intent = new Intent(EthernetManager.NETWORK_STATE_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(EthernetManager.EXTRA_NETWORK_INFO, new NetworkInfo(mNetworkInfo));
+        intent.putExtra(EthernetManager.EXTRA_LINK_PROPERTIES, new LinkProperties (mLinkProperties));
+        if (mNetworkInfo.getDetailedState() == DetailedState.CONNECTED) {
+            intent.putExtra(EthernetManager.EXTRA_ETHERNET_INFO, new EthernetInfo(mEthernetInfo));
+        }
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendLinkConfigurationChangedBroadcast() {
+        Intent intent = new Intent(EthernetManager.LINK_CONFIGURATION_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(EthernetManager.EXTRA_LINK_PROPERTIES, new LinkProperties(mLinkProperties));
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    /**
+     * Record the detailed state of a network.
+     * @param state the new {@code DetailedState}
+     */
+    private void setNetworkDetailedState(NetworkInfo.DetailedState state) {
+        if (DBG) {
+            log("setDetailed state, old ="
+                    + mNetworkInfo.getDetailedState() + " and new state=" + state);
+        }
+
+        if (state != mNetworkInfo.getDetailedState()) {
+            mNetworkInfo.setDetailedState(state, null, mEthernetInfo.getSSID());
+        }
+    }
+
+    private DetailedState getNetworkDetailedState() {
+        return mNetworkInfo.getDetailedState();
+    }
+
+    /**
+     * Resets the Ethernet Connections by clearing any state, resetting any sockets
+     * using the interface, stopping DHCP & disabling interface
+     */
+    private void handleNetworkDisconnect() {
+        if (DBG) log("Stopping DHCP and clearing IP");
+
+        /*
+         * stop DHCP
+         */
+        if (mDhcpStateMachine != null) {
+            /* In case we were in middle of DHCP operation
+               restore back powermode */
+            handlePostDhcpSetup();
+            mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_STOP_DHCP);
+        }
+
+        try {
+            mNwService.clearInterfaceAddresses(mInterfaceName);
+            mNwService.disableIpv6(mInterfaceName);
+        } catch (Exception e) {
+            loge("Failed to clear addresses or disable ipv6" + e);
+        }
+
+        /* Reset data structures */
+        mEthernetInfo.setInetAddress(null);
+        mEthernetInfo.setName(null);
+        mEthernetInfo.setNetworkId(EthernetConfiguration.INVALID_NETWORK_ID);
+        mEthernetInfo.setLinkSpeed(-1);
+
+        setNetworkDetailedState(DetailedState.DISCONNECTED);
+        mEthernetConfigStore.updateStatus(mLastNetworkId, DetailedState.DISCONNECTED);
+
+        /* send event to CM & network change broadcast */
+        sendNetworkStateChangeBroadcast(mLastBssid);
+
+        /* Clear network properties */
+        mLinkProperties.clear();
+
+        /* Clear IP settings if the network used DHCP */
+        if (!mEthernetConfigStore.isUsingStaticIp(mLastNetworkId)) {
+            mEthernetConfigStore.clearIpConfiguration(mLastNetworkId);
+        }
+
+        mLastNetworkId = EthernetConfiguration.INVALID_NETWORK_ID;
+    }
+
+    void handlePreDhcpSetup() {
+        /* Disable power save and suspend optimizations during DHCP */
+        setSuspendOptimizationsNative(SUSPEND_DUE_TO_DHCP, false);
+        mEthernetNative.setPowerSave(false);
+    }
+
+    void handlePostDhcpSetup() {
+        /* Restore power save and suspend optimizations */
+        setSuspendOptimizationsNative(SUSPEND_DUE_TO_DHCP, true);
+        mEthernetNative.setPowerSave(true);
+    }
+
+    private void handleSuccessfulIpConfiguration(DhcpInfoInternal dhcpInfoInternal) {
+        synchronized (mDhcpInfoInternal) {
+            mDhcpInfoInternal = dhcpInfoInternal;
+        }
+        mReconnectCount = 0; //Reset IP failure tracking
+        mEthernetConfigStore.setIpConfiguration(mLastNetworkId, dhcpInfoInternal);
+        InetAddress addr = NetworkUtils.numericToInetAddress(dhcpInfoInternal.ipAddress);
+        mEthernetInfo.setInetAddress(addr);
+        if (getNetworkDetailedState() == DetailedState.CONNECTED) {
+            //DHCP renewal in connected state
+            LinkProperties linkProperties = dhcpInfoInternal.makeLinkProperties();
+            linkProperties.setHttpProxy(mEthernetConfigStore.getProxyProperties(mLastNetworkId));
+            linkProperties.setInterfaceName(mInterfaceName);
+            if (!linkProperties.equals(mLinkProperties)) {
+                if (DBG) {
+                    log("Link configuration changed for netId: " + mLastNetworkId
+                            + " old: " + mLinkProperties + "new: " + linkProperties);
+                }
+                mLinkProperties = linkProperties;
+                sendLinkConfigurationChangedBroadcast();
+            }
+        } else {
+            configureLinkProperties();
+        }
+    }
+
+    private void handleFailedIpConfiguration() {
+        loge("IP configuration failed");
+
+        mEthernetInfo.setInetAddress(null);
+        /**
+         * If we've exceeded the maximum number of retries for DHCP
+         * to a given network, disable the network
+         */
+        int maxRetries = getMaxDhcpRetries();
+        // maxRetries == 0 means keep trying forever
+        if (maxRetries > 0 && ++mReconnectCount > maxRetries) {
+            loge("Failed " +
+                    mReconnectCount + " times, Disabling " + mLastNetworkId);
+            mEthernetConfigStore.disableNetwork(mLastNetworkId,
+                    EthernetConfiguration.DISABLED_DHCP_FAILURE);
+            mReconnectCount = 0;
+        }
+
+        /* DHCP times out after about 30 seconds, we do a
+         * disconnect and an immediate reconnect to try again
+         */
+        mEthernetNative.disconnect();
+        mEthernetNative.reconnect();
+    }
+
+    /********************************************************
+     * HSM states
+     *******************************************************/
+
+    class DefaultState extends State {
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+            switch (message.what) {
+                case CMD_ENABLE_NETWORK:
+                case CMD_ADD_OR_UPDATE_NETWORK:
+                case CMD_REMOVE_NETWORK:
+                case CMD_SAVE_CONFIG:
+                    replyToMessage(message, message.what, FAILURE);
+                    break;
+                case CMD_GET_CONFIGURED_NETWORKS:
+                    replyToMessage(message, message.what, (List<EthernetConfiguration>) null);
+                    break;
+                case CMD_SET_HIGH_PERF_MODE:
+                    if (message.arg1 == 1) {
+                        setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
+                    } else {
+                        setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
+                    }
+                    break;
+                    /* Discard */
+                case CMD_LOAD_DRIVER:
+                case CMD_UNLOAD_DRIVER:
+                case CMD_TETHER_STATE_CHANGE:
+                case CMD_TETHER_NOTIFICATION_TIMED_OUT:
+                case CMD_DISCONNECT:
+                case CMD_RECONNECT:
+                case EthernetMonitor.NETWORK_CONNECTION_EVENT:
+                case EthernetMonitor.NETWORK_DISCONNECTION_EVENT:
+                case CMD_ENABLE_ALL_NETWORKS:
+                case DhcpStateMachine.CMD_PRE_DHCP_ACTION:
+                case DhcpStateMachine.CMD_POST_DHCP_ACTION:
+                    break;
+                case DhcpStateMachine.CMD_ON_QUIT:
+                    mDhcpStateMachine = null;
+                    break;
+                case CMD_SET_SUSPEND_OPT_ENABLED:
+                    if (message.arg1 == 1) {
+                        mSuspendWakeLock.release();
+                        setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
+                    } else {
+                        setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
+                    }
+                    break;
+                case EthernetManager.CONNECT_NETWORK:
+                    replyToMessage(message, EthernetManager.CONNECT_NETWORK_FAILED,
+                            EthernetManager.BUSY);
+                    break;
+                case EthernetManager.FORGET_NETWORK:
+                    replyToMessage(message, EthernetManager.FORGET_NETWORK_FAILED,
+                            EthernetManager.BUSY);
+                    break;
+                case EthernetManager.SAVE_NETWORK:
+                    replyToMessage(message, EthernetManager.SAVE_NETWORK_FAILED,
+                            EthernetManager.BUSY);
+                    break;
+                case EthernetManager.DISABLE_NETWORK:
+                    replyToMessage(message, EthernetManager.DISABLE_NETWORK_FAILED,
+                            EthernetManager.BUSY);
+                    break;
+                default:
+                    loge("Error! unhandled message" + message);
+                    break;
+            }
+            return HANDLED;
+        }
+    }
+
+    class InitialState extends State {
+        @Override
+        //TODO: could move logging into a common class
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            // [31-8] Reserved for future use
+            // [7 - 0] HSM state change
+            // 50031 ethernet_state_changed (custom|1|5)
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+
+            if (mEthernetNative.isDriverLoaded()) {
+                transitionTo(mDriverLoadedState);
+            }
+            else {
+                transitionTo(mDriverUnloadedState);
+            }
+
+            /* IPv6 is disabled at boot time and is controlled by framework
+             * to be enabled only as long as we are connected
+             *
+             * This fixes issues, a few being:
+             * - IPv6 addresses and routes stick around after disconnection
+             * - When connected, the kernel is unaware and can fail to start IPv6 negotiation
+             * - The kernel sometimes starts autoconfiguration when 802.3 is not complete
+             */
+            try {
+                mNwService.disableIpv6(mInterfaceName);
+            } catch (RemoteException re) {
+                loge("Failed to disable IPv6: " + re);
+            } catch (IllegalStateException e) {
+                loge("Failed to disable IPv6: " + e);
+            }
+        }
+    }
+
+    class DriverLoadingState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+
+            final Message message = new Message();
+            message.copyFrom(getCurrentMessage());
+
+            new Thread(new Runnable() {
+                public void run() {
+                    mWakeLock.acquire();
+                    //enabling state
+                    switch(message.arg1) {
+                        case ETHERNET_STATE_ENABLING:
+                            setEthernetState(ETHERNET_STATE_ENABLING);
+                            break;
+                        case ETHERNET_AP_STATE_ENABLING:
+                            setEthernetApState(ETHERNET_AP_STATE_ENABLING);
+                            break;
+                    }
+
+                    if(mEthernetNative.loadDriver()) {
+                        if (DBG) log("Driver load successful");
+                        sendMessage(CMD_LOAD_DRIVER_SUCCESS);
+                    } else {
+                        loge("Failed to load driver!");
+                        switch(message.arg1) {
+                            case ETHERNET_STATE_ENABLING:
+                                setEthernetState(ETHERNET_STATE_UNKNOWN);
+                                break;
+			    default:
+                                break;
+                        }
+                        sendMessage(CMD_LOAD_DRIVER_FAILURE);
+                    }
+                    mWakeLock.release();
+                }
+            }).start();
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+            switch (message.what) {
+                case CMD_LOAD_DRIVER_SUCCESS:
+                    transitionTo(mDriverLoadedState);
+                    break;
+                case CMD_LOAD_DRIVER_FAILURE:
+                    transitionTo(mDriverFailedState);
+                    break;
+                case CMD_LOAD_DRIVER:
+                case CMD_UNLOAD_DRIVER:
+                case CMD_START_PACKET_FILTERING:
+                case CMD_STOP_PACKET_FILTERING:
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class DriverLoadedState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+            switch(message.what) {
+                case CMD_UNLOAD_DRIVER:
+                    transitionTo(mDriverUnloadingState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class DriverUnloadingState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+
+            final Message message = new Message();
+            message.copyFrom(getCurrentMessage());
+            new Thread(new Runnable() {
+                public void run() {
+                    if (DBG) log(getName() + message.toString() + "\n");
+                    mWakeLock.acquire();
+                    if(mEthernetNative.unloadDriver()) {
+                        if (DBG) log("Driver unload successful");
+                        sendMessage(CMD_UNLOAD_DRIVER_SUCCESS);
+
+                        switch(message.arg1) {
+                            case ETHERNET_STATE_DISABLED:
+                            case ETHERNET_STATE_UNKNOWN:
+                                setEthernetState(message.arg1);
+                                break;
+                        }
+                    } else {
+                        loge("Failed to unload driver!");
+                        sendMessage(CMD_UNLOAD_DRIVER_FAILURE);
+
+                        switch(message.arg1) {
+                            case ETHERNET_STATE_DISABLED:
+                            case ETHERNET_STATE_UNKNOWN:
+                                setEthernetState(ETHERNET_STATE_UNKNOWN);
+                                break;
+                        }
+                    }
+                    mWakeLock.release();
+                }
+            }).start();
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+            switch (message.what) {
+                case CMD_UNLOAD_DRIVER_SUCCESS:
+                    transitionTo(mDriverUnloadedState);
+                    break;
+                case CMD_UNLOAD_DRIVER_FAILURE:
+                    transitionTo(mDriverFailedState);
+                    break;
+                case CMD_LOAD_DRIVER:
+                case CMD_UNLOAD_DRIVER:
+                case CMD_START_PACKET_FILTERING:
+                case CMD_STOP_PACKET_FILTERING:
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class DriverUnloadedState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+            switch (message.what) {
+                case CMD_LOAD_DRIVER:
+                    transitionTo(mDriverLoadingState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class DriverFailedState extends State {
+        @Override
+        public void enter() {
+            loge(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+            return NOT_HANDLED;
+        }
+    }
+
+    class ConnectModeState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+            StateChangeResult stateChangeResult;
+            switch(message.what) {
+                case CMD_DISCONNECT:
+                    mEthernetNative.disconnect();
+                    break;
+                case CMD_RECONNECT:
+                    mEthernetNative.reconnect();
+                    break;
+                case EthernetManager.CONNECT_NETWORK:
+                    /* The connect message can contain a network id passed as arg1 on message or
+                     * or a config passed as obj on message.
+                     * For a new network, a config is passed to create and connect.
+                     * For an existing network, a network id is passed
+                     */
+                    int netId = message.arg1;
+                    EthernetConfiguration config = (EthernetConfiguration) message.obj;
+
+                    /* Save the network config */
+                    if (config != null) {
+                        NetworkUpdateResult result = mEthernetConfigStore.saveNetwork(config);
+                        netId = result.getNetworkId();
+                    }
+
+                    if (mEthernetConfigStore.selectNetwork(netId) &&
+                            mEthernetNative.reconnect()) {
+                        /* The state tracker handles enabling networks upon completion/failure */
+                        mSupplicantStateTracker.sendMessage(EthernetManager.CONNECT_NETWORK);
+                        replyToMessage(message, EthernetManager.CONNECT_NETWORK_SUCCEEDED);
+                        /* Expect a disconnection from the old connection */
+                        transitionTo(mDisconnectingState);
+                    } else {
+                        loge("Failed to connect config: " + config + " netId: " + netId);
+                        replyToMessage(message, EthernetManager.CONNECT_NETWORK_FAILED,
+                                EthernetManager.ERROR);
+                        break;
+                    }
+                    break;
+                case EthernetMonitor.NETWORK_CONNECTION_EVENT:
+                    if (DBG) log("Network connection established");
+                    mLastNetworkId = message.arg1;
+                    mLastName = (String) message.obj;
+
+                    mEthernetInfo.setName(mLastName);
+                    mEthernetInfo.setNetworkId(mLastNetworkId);
+                    /* send event to CM & network change broadcast */
+                    setNetworkDetailedState(DetailedState.OBTAINING_IPADDR);
+                    sendNetworkStateChangeBroadcast(mLastName);
+                    transitionTo(mObtainingIpState);
+                    break;
+                case EthernetMonitor.NETWORK_DISCONNECTION_EVENT:
+                    if (DBG) log("Network connection lost");
+                    handleNetworkDisconnect();
+                    transitionTo(mDisconnectedState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class L2ConnectedState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+            switch (message.what) {
+              case DhcpStateMachine.CMD_PRE_DHCP_ACTION:
+                  handlePreDhcpSetup();
+                  mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_PRE_DHCP_ACTION_COMPLETE);
+                  break;
+              case DhcpStateMachine.CMD_POST_DHCP_ACTION:
+                  handlePostDhcpSetup();
+                  if (message.arg1 == DhcpStateMachine.DHCP_SUCCESS) {
+                      if (DBG) log("DHCP successful");
+                      handleSuccessfulIpConfiguration((DhcpInfoInternal) message.obj);
+                      transitionTo(mCaptivePortalCheckState);
+                  } else if (message.arg1 == DhcpStateMachine.DHCP_FAILURE) {
+                      if (DBG) log("DHCP failed");
+                      handleFailedIpConfiguration();
+                      transitionTo(mDisconnectingState);
+                  }
+                  break;
+                case CMD_DISCONNECT:
+                    mEthernetNative.disconnect();
+                    transitionTo(mDisconnectingState);
+                    break;
+                case EthernetManager.CONNECT_NETWORK:
+                    int netId = message.arg1;
+                    if (mEthernetInfo.getNetworkId() == netId) {
+                        break;
+                    }
+                    return NOT_HANDLED;
+                case EthernetManager.SAVE_NETWORK:
+                    EthernetConfiguration config = (EthernetConfiguration) message.obj;
+                    NetworkUpdateResult result = mEthernetConfigStore.saveNetwork(config);
+                    if (mEthernetInfo.getNetworkId() == result.getNetworkId()) {
+                        if (result.hasIpChanged()) {
+                            log("Reconfiguring IP on connection");
+                            transitionTo(mObtainingIpState);
+                        }
+                        if (result.hasProxyChanged()) {
+                            log("Reconfiguring proxy on connection");
+                            configureLinkProperties();
+                            sendLinkConfigurationChangedBroadcast();
+                        }
+                    }
+
+                    if (result.getNetworkId() != EthernetConfiguration.INVALID_NETWORK_ID) {
+                        replyToMessage(message, EthernetManager.SAVE_NETWORK_SUCCEEDED);
+                    } else {
+                        loge("Failed to save network");
+                        replyToMessage(message, EthernetManager.SAVE_NETWORK_FAILED,
+                                EthernetManager.ERROR);
+                    }
+                    break;
+                    /* Ignore */
+                case EthernetMonitor.NETWORK_CONNECTION_EVENT:
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+
+            return HANDLED;
+        }
+    }
+
+    class ObtainingIpState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+
+            if (!mEthernetConfigStore.isUsingStaticIp(mLastNetworkId)) {
+                //start DHCP
+                if (mDhcpStateMachine == null) {
+                    mDhcpStateMachine = DhcpStateMachine.makeDhcpStateMachine(
+                            mContext, EthernetStateMachine.this, mInterfaceName);
+
+                }
+                mDhcpStateMachine.registerForPreDhcpNotification();
+                mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_START_DHCP);
+            } else {
+                DhcpInfoInternal dhcpInfoInternal = mEthernetConfigStore.getIpConfiguration(
+                        mLastNetworkId);
+                InterfaceConfiguration ifcg = new InterfaceConfiguration();
+                ifcg.setLinkAddress(dhcpInfoInternal.makeLinkAddress());
+                ifcg.setInterfaceUp();
+                try {
+                    mNwService.setInterfaceConfig(mInterfaceName, ifcg);
+                    if (DBG) log("Static IP configuration succeeded");
+                    sendMessage(CMD_STATIC_IP_SUCCESS, dhcpInfoInternal);
+                } catch (RemoteException re) {
+                    loge("Static IP configuration failed: " + re);
+                    sendMessage(CMD_STATIC_IP_FAILURE);
+                } catch (IllegalStateException e) {
+                    loge("Static IP configuration failed: " + e);
+                    sendMessage(CMD_STATIC_IP_FAILURE);
+                }
+            }
+        }
+      @Override
+      public boolean processMessage(Message message) {
+          if (DBG) log(getName() + message.toString() + "\n");
+          switch(message.what) {
+            case CMD_STATIC_IP_SUCCESS:
+                  handleSuccessfulIpConfiguration((DhcpInfoInternal) message.obj);
+                  transitionTo(mCaptivePortalCheckState);
+                  break;
+              case CMD_STATIC_IP_FAILURE:
+                  handleFailedIpConfiguration();
+                  transitionTo(mDisconnectingState);
+                  break;
+             case EthernetManager.SAVE_NETWORK:
+                  deferMessage(message);
+                  break;
+                  /* Defer any power mode changes since we must keep active power mode at DHCP */
+              case CMD_SET_HIGH_PERF_MODE:
+                  deferMessage(message);
+                  break;
+              default:
+                  return NOT_HANDLED;
+          }
+          return HANDLED;
+      }
+    }
+
+    class CaptivePortalCheckState extends State {
+        @Override
+        public void enter() {
+            setNetworkDetailedState(DetailedState.CAPTIVE_PORTAL_CHECK);
+            mEthernetConfigStore.updateStatus(mLastNetworkId, DetailedState.CAPTIVE_PORTAL_CHECK);
+            sendNetworkStateChangeBroadcast(mLastName);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            switch (message.what) {
+                case CMD_CAPTIVE_CHECK_COMPLETE:
+                    try {
+                        mNwService.enableIpv6(mInterfaceName);
+                    } catch (RemoteException re) {
+                        loge("Failed to enable IPv6: " + re);
+                    } catch (IllegalStateException e) {
+                        loge("Failed to enable IPv6: " + e);
+                    }
+                    setNetworkDetailedState(DetailedState.CONNECTED);
+                    mEthernetConfigStore.updateStatus(mLastNetworkId, DetailedState.CONNECTED);
+                    sendNetworkStateChangeBroadcast(mLastName);
+                    transitionTo(mConnectedState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class ConnectedState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+       }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+	    return NOT_HANDLED;
+        }
+        @Override
+        public void exit() {
+            /* Request a CS wakelock during transition to mobile */
+            checkAndSetConnectivityInstance();
+            mCm.requestNetworkTransitionWakelock(TAG);
+        }
+    }
+
+    class DisconnectingState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+	    return NOT_HANDLED;
+        }
+    }
+
+    class DisconnectedState extends State {
+        private boolean mAlarmEnabled = false;
+        /* This is set from the overlay config file or from a secure setting.
+         * A value of 0 disables scanning in the framework.
+         */
+
+        @Override
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+            boolean ret = HANDLED;
+            switch (message.what) {
+                case EthernetManager.FORGET_NETWORK:
+                case CMD_REMOVE_NETWORK:
+                    sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN,
+                                ++mPeriodicScanToken, 0), mSupplicantScanIntervalMs);
+                    ret = NOT_HANDLED;
+                    break;
+                case EthernetMonitor.NETWORK_DISCONNECTION_EVENT:
+                    break;
+                case CMD_RECONNECT:
+                    if (mTemporarilyDisconnectEthernet) ret = NOT_HANDLED;
+                    break;
+                default:
+                    ret = NOT_HANDLED;
+            }
+            return ret;
+        }
+    }
+
+    class TetheringState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+
+            /* Send ourselves a delayed message to shut down if tethering fails to notify */
+            sendMessageDelayed(obtainMessage(CMD_TETHER_NOTIFICATION_TIMED_OUT,
+                    ++mTetherToken, 0), TETHER_NOTIFICATION_TIME_OUT_MSECS);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+            switch(message.what) {
+                case CMD_TETHER_STATE_CHANGE:
+                    TetherStateChange stateChange = (TetherStateChange) message.obj;
+                    if (isEthernetTethered(stateChange.active)) {
+                        transitionTo(mTetheredState);
+                    }
+                    return HANDLED;
+                case CMD_TETHER_NOTIFICATION_TIMED_OUT:
+                    if (message.arg1 == mTetherToken) {
+                        loge("Failed to get tether update, shutdown soft access point");
+                    }
+                    break;
+                case CMD_LOAD_DRIVER:
+                case CMD_UNLOAD_DRIVER:
+                case CMD_START_PACKET_FILTERING:
+                case CMD_STOP_PACKET_FILTERING:
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class TetheredState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log(getName() + "\n");
+            EventLog.writeEvent(EVENTLOG_ETHERNET_STATE_CHANGED, getName());
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) log(getName() + message.toString() + "\n");
+            switch(message.what) {
+                case CMD_TETHER_STATE_CHANGE:
+                    TetherStateChange stateChange = (TetherStateChange) message.obj;
+                    if (!isEthernetTethered(stateChange.active)) {
+                        loge("Tethering reports ethernet as untethered!, shut down soft Ap");
+                    }
+                    return HANDLED;
+                case CMD_STOP_AP:
+                    if (DBG) log("Untethering before stopping AP");
+                    setEthernetApState(ETHERNET_AP_STATE_DISABLING);
+                    stopTethering();
+                    transitionTo(mSoftApStoppingState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    //State machine initiated requests can have replyTo set to null indicating
+    //there are no recepients, we ignore those reply actions
+    private void replyToMessage(Message msg, int what) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessageWithArg2(msg);
+        dstMsg.what = what;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+
+    private void replyToMessage(Message msg, int what, int arg1) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessageWithArg2(msg);
+        dstMsg.what = what;
+        dstMsg.arg1 = arg1;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+
+    private void replyToMessage(Message msg, int what, Object obj) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessageWithArg2(msg);
+        dstMsg.what = what;
+        dstMsg.obj = obj;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+
+    /**
+     * arg2 on the source message has a unique id that needs to be retained in replies
+     * to match the request
+     *
+     * see EthernetManager for details
+     */
+    private Message obtainMessageWithArg2(Message srcMsg) {
+        Message msg = Message.obtain();
+        msg.arg2 = srcMsg.arg2;
+        return msg;
+    }
+
+    private void log(String s) {
+        Log.d(TAG, s);
+    }
+
+    private void loge(String s) {
+        Log.e(TAG, s);
+    }
+}
diff --git a/ethernet/java/android/net/ethernet/EthernetStateTracker.java b/ethernet/java/android/net/ethernet/EthernetStateTracker.java
new file mode 100644
index 0000000..3e824a4
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/EthernetStateTracker.java
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.ethernet;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.LinkCapabilities;
+import android.net.LinkProperties;
+import android.net.NetworkInfo;
+import android.net.NetworkInfo.DetailedState;
+import android.net.NetworkStateTracker;
+import android.os.Handler;
+import android.os.Message;
+import android.util.Slog;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/**
+ * Track the state of ethernet for connectivity service.
+ *
+ * @hide
+ */
+public class EthernetStateTracker implements NetworkStateTracker {
+
+    private static final String NETWORKTYPE = "ETHERNET";
+    private static final String TAG = "EthernetStateTracker";
+
+    private static final boolean LOGV = true;
+
+    private AtomicBoolean mTeardownRequested = new AtomicBoolean(false);
+    private AtomicBoolean mPrivateDnsRouteSet = new AtomicBoolean(false);
+    private AtomicBoolean mDefaultRouteSet = new AtomicBoolean(false);
+
+    private LinkProperties mLinkProperties;
+    private LinkCapabilities mLinkCapabilities;
+    private NetworkInfo mNetworkInfo;
+    private NetworkInfo.State mLastState = NetworkInfo.State.UNKNOWN;
+
+    /* For sending events to connectivity service handler */
+    private Handler mCsHandler;
+    private Context mContext;
+    private BroadcastReceiver mEthernetStateReceiver;
+    private EthernetManager mEthernetManager;
+
+    public EthernetStateTracker(int netType, String networkName) {
+        mNetworkInfo = new NetworkInfo(netType, 0, networkName, "");
+        mLinkProperties = new LinkProperties();
+        mLinkCapabilities = new LinkCapabilities();
+
+        mNetworkInfo.setIsAvailable(false);
+        setTeardownRequested(false);
+    }
+
+
+    public void setTeardownRequested(boolean isRequested) {
+        mTeardownRequested.set(isRequested);
+    }
+
+    public boolean isTeardownRequested() {
+        return mTeardownRequested.get();
+    }
+
+    /**
+     * Begin monitoring ethernet connectivity
+     */
+    public void startMonitoring(Context context, Handler target) {
+        mCsHandler = target;
+        mContext = context;
+
+        mEthernetManager = (EthernetManager) mContext.getSystemService(Context.ETHERNET_SERVICE);
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(EthernetManager.NETWORK_STATE_CHANGED_ACTION);
+        filter.addAction(EthernetManager.LINK_CONFIGURATION_CHANGED_ACTION);
+
+        mEthernetStateReceiver = new EthernetStateReceiver();
+        mContext.registerReceiver(mEthernetStateReceiver, filter);
+    }
+
+    /**
+     * Disable connectivity to a network
+     */
+    public boolean teardown() {
+        mTeardownRequested.set(true);
+        mEthernetManager.stopEthernet();
+        return true;
+    }
+
+    /**
+     * Re-enable connectivity to a network after a {@link #teardown()}.
+     */
+    public boolean reconnect() {
+        mTeardownRequested.set(false);
+        mEthernetManager.startEthernet();
+        return true;
+    }
+
+    /**
+     * Captive check is complete, switch to network
+     */
+    @Override
+    public void captivePortalCheckComplete() {
+        mEthernetManager.captivePortalCheckComplete();
+    }
+
+    /**
+     * Turn the wireless radio off for a network.
+     * @param turnOn {@code true} to turn the radio on, {@code false}
+     */
+    public boolean setRadio(boolean turnOn) {
+	mEthernetManager.setEthernetEnabled(turnOn);	
+	return true;
+    }
+
+    /**
+     * Ethernet is considered available as long as there is at least one
+     * enabled network. If a teardown was explicitly requested, then Ethernet
+     * can be restarted with a reconnect request, so it is considered available.
+     * If the driver has been stopped for any reason other than a teardown
+     * request, Ethernet is considered unavailable.
+     * @return {@code true} if Ethernet connections are possible
+     */
+    public boolean isAvailable() {
+        return mNetworkInfo.isAvailable();
+    }
+
+    @Override
+    public void setUserDataEnable(boolean enabled) {
+        Slog.w(TAG, "ignoring setUserDataEnable(" + enabled + ")");
+    }
+
+    @Override
+    public void setPolicyDataEnable(boolean enabled) {
+        // ignored
+    }
+
+    /**
+     * Check if private DNS route is set for the network
+     */
+    public boolean isPrivateDnsRouteSet() {
+        return mPrivateDnsRouteSet.get();
+    }
+
+    /**
+     * Set a flag indicating private DNS route is set
+     */
+    public void privateDnsRouteSet(boolean enabled) {
+        mPrivateDnsRouteSet.set(enabled);
+    }
+
+    /**
+     * Fetch NetworkInfo for the network
+     */
+    public NetworkInfo getNetworkInfo() {
+        return new NetworkInfo(mNetworkInfo);
+    }
+
+    /**
+     * Fetch LinkProperties for the network
+     */
+    public LinkProperties getLinkProperties() {
+        return new LinkProperties(mLinkProperties);
+    }
+
+    /**
+     * A capability is an Integer/String pair, the capabilities
+     * are defined in the class LinkSocket#Key.
+     *
+     * @return a copy of this connections capabilities, may be empty but never null.
+     */
+    public LinkCapabilities getLinkCapabilities() {
+        return new LinkCapabilities(mLinkCapabilities);
+    }
+
+    /**
+     * Check if default route is set
+     */
+    public boolean isDefaultRouteSet() {
+        return mDefaultRouteSet.get();
+    }
+
+    /**
+     * Set a flag indicating default route is set for the network
+     */
+    public void defaultRouteSet(boolean enabled) {
+        mDefaultRouteSet.set(enabled);
+    }
+
+    /**
+     * Return the system properties name associated with the tcp buffer sizes
+     * for this network.
+     */
+    public String getTcpBufferSizesPropName() {
+        return "net.tcp.buffersize.ethernet";
+    }
+
+    private class EthernetStateReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+
+            if (intent.getAction().equals(EthernetManager.NETWORK_STATE_CHANGED_ACTION)) {
+                mNetworkInfo = (NetworkInfo) intent.getParcelableExtra(
+                        EthernetManager.EXTRA_NETWORK_INFO);
+                mLinkProperties = intent.getParcelableExtra(
+                        EthernetManager.EXTRA_LINK_PROPERTIES);
+                if (mLinkProperties == null) {
+                    mLinkProperties = new LinkProperties();
+                }
+                mLinkCapabilities = intent.getParcelableExtra(
+                        EthernetManager.EXTRA_LINK_CAPABILITIES);
+                if (mLinkCapabilities == null) {
+                    mLinkCapabilities = new LinkCapabilities();
+                }
+                // don't want to send redundent state messages
+                // but send portal check detailed state notice
+                NetworkInfo.State state = mNetworkInfo.getState();
+                if (mLastState == state &&
+                        mNetworkInfo.getDetailedState() != DetailedState.CAPTIVE_PORTAL_CHECK) {
+                    return;
+                } else {
+                    mLastState = state;
+                }
+                Message msg = mCsHandler.obtainMessage(EVENT_STATE_CHANGED,
+                        new NetworkInfo(mNetworkInfo));
+                msg.sendToTarget();
+            } else if (intent.getAction().equals(EthernetManager.LINK_CONFIGURATION_CHANGED_ACTION)) {
+                mLinkProperties = (LinkProperties) intent.getParcelableExtra(
+                        EthernetManager.EXTRA_LINK_PROPERTIES);
+                Message msg = mCsHandler.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
+                msg.sendToTarget();
+            }
+        }
+    }
+
+    public void setDependencyMet(boolean met) {
+        // not supported on this network
+    }
+}
diff --git a/ethernet/java/android/net/ethernet/IEthernetManager.aidl b/ethernet/java/android/net/ethernet/IEthernetManager.aidl
new file mode 100644
index 0000000..55c3508
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/IEthernetManager.aidl
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.ethernet;
+
+import android.net.ethernet.EthernetInfo;
+import android.net.ethernet.EthernetConfiguration;
+import android.net.DhcpInfo;
+
+import android.os.Messenger;
+import android.os.WorkSource;
+
+/**
+ * Interface that allows controlling and querying Ethernet connectivity.
+ *
+ * {@hide}
+ */
+interface IEthernetManager
+{
+    List<EthernetConfiguration> getConfiguredNetworks();
+
+    int addOrUpdateNetwork(in EthernetConfiguration config);
+
+    boolean removeNetwork(int netId);
+
+    boolean enableNetwork(int netId, boolean disableOthers);
+
+    boolean disableNetwork(int netId);
+
+    boolean disconnect();
+
+    boolean reconnect();
+
+    EthernetInfo getConnectionInfo();
+
+    boolean setEthernetEnabled(boolean enabled);
+
+    int getEthernetState();
+
+    boolean isEthernetEnabled();
+
+    boolean saveConfiguration();
+
+    DhcpInfo getDhcpInfo();
+
+    boolean acquireEthernetLock(IBinder lock, int lockType, String tag, in WorkSource ws);
+
+    void updateEthernetLockWorkSource(IBinder lock, in WorkSource ws);
+
+    boolean releaseEthernetLock(IBinder lock);
+
+    boolean initializeMulticastFiltering();
+
+    boolean isMulticastEnabled();
+
+    void acquireMulticastLock(IBinder binder, String tag);
+
+    void releaseMulticastLock();
+
+    boolean startEthernet();
+
+    boolean stopEthernet();
+
+    Messenger getEthernetServiceMessenger();
+
+    Messenger getEthernetStateMachineMessenger();
+
+    String getConfigFile();
+
+    void captivePortalCheckComplete();
+}
diff --git a/ethernet/java/android/net/ethernet/NetworkUpdateResult.java b/ethernet/java/android/net/ethernet/NetworkUpdateResult.java
new file mode 100644
index 0000000..9bf4356
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/NetworkUpdateResult.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.ethernet;
+
+import static android.net.ethernet.EthernetConfiguration.INVALID_NETWORK_ID;
+
+class NetworkUpdateResult {
+    int netId;
+    boolean ipChanged;
+    boolean proxyChanged;
+    boolean isNewNetwork = false;
+
+    public NetworkUpdateResult(int id) {
+        netId = id;
+        ipChanged = false;
+        proxyChanged = false;
+    }
+
+    public NetworkUpdateResult(boolean ip, boolean proxy) {
+        netId = INVALID_NETWORK_ID;
+        ipChanged = ip;
+        proxyChanged = proxy;
+    }
+
+    public void setNetworkId(int id) {
+        netId = id;
+    }
+
+    public int getNetworkId() {
+        return netId;
+    }
+
+    public void setIpChanged(boolean ip) {
+        ipChanged = ip;
+    }
+
+    public boolean hasIpChanged() {
+        return ipChanged;
+    }
+
+    public void setProxyChanged(boolean proxy) {
+        proxyChanged = proxy;
+    }
+
+    public boolean hasProxyChanged() {
+        return proxyChanged;
+    }
+
+    public boolean isNewNetwork() {
+        return isNewNetwork;
+    }
+
+    public void setIsNewNetwork(boolean isNew) {
+        isNewNetwork = isNew;
+    }
+}
diff --git a/ethernet/java/android/net/ethernet/package.html b/ethernet/java/android/net/ethernet/package.html
new file mode 100644
index 0000000..df9668b
--- /dev/null
+++ b/ethernet/java/android/net/ethernet/package.html
@@ -0,0 +1,29 @@
+<HTML>
+<BODY>
+<p>Provides classes to manage Ethernet functionality on the device.</p>
+<p>The Ethernet APIs provide a means by which applications can communicate 
+with the lower-level ethernet stack that provides Ethernet network access. Almost all
+information from the device is available, including the connected network's
+link speed, IP address, negotiation state, and more, plus information about other
+networks that are available. Some other API features include the ability to
+add, save, terminate and initiate Ethernet connections.</p>
+
+<p>Some APIs may require the following user permissions:</p>
+<ul>
+  <li>{@link android.Manifest.permission#ACCESS_ETHERNET_STATE}</li>
+  <li>{@link android.Manifest.permission#CHANGE_ETHERNET_STATE}</li>
+  <li>{@link android.Manifest.permission#CHANGE_ETHERNET_MULTICAST_STATE}</li>
+</ul>
+
+<p class="note"><strong>Note:</strong> Not all Android-powered devices provide Ethernet functionality.
+If your application uses Ethernet, declare so with a <a
+href="{@docRoot}guide/topics/manifest/uses-feature-element.html">{@code &lt;uses-feature&gt;}</a>
+element in the manifest file:</p>
+<pre>
+&lt;manifest ...>
+    &lt;uses-feature android:name="android.hardware.ethernet" />
+    ...
+&lt;/manifest>
+</pre>
+</BODY>
+</HTML>
diff --git a/packages/SystemUI/res/drawable-hdpi/connect_creating.png b/packages/SystemUI/res/drawable-hdpi/connect_creating.png
new file mode 100755
index 0000000..a70572c
Binary files /dev/null and b/packages/SystemUI/res/drawable-hdpi/connect_creating.png differ
diff --git a/packages/SystemUI/res/drawable-hdpi/connect_established.png b/packages/SystemUI/res/drawable-hdpi/connect_established.png
new file mode 100755
index 0000000..cd8c435
Binary files /dev/null and b/packages/SystemUI/res/drawable-hdpi/connect_established.png differ
diff --git a/packages/SystemUI/res/drawable-hdpi/connect_no.png b/packages/SystemUI/res/drawable-hdpi/connect_no.png
new file mode 100755
index 0000000..ea63cdd
Binary files /dev/null and b/packages/SystemUI/res/drawable-hdpi/connect_no.png differ
diff --git a/packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000..da4e162
Binary files /dev/null and b/packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_connected.png differ
diff --git a/packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000..932bac1
Binary files /dev/null and b/packages/SystemUI/res/drawable-hdpi/stat_sys_ethernet_disconnected.png differ
diff --git a/packages/SystemUI/res/drawable-mdpi/connect_creating.png b/packages/SystemUI/res/drawable-mdpi/connect_creating.png
new file mode 100755
index 0000000..cb507da
Binary files /dev/null and b/packages/SystemUI/res/drawable-mdpi/connect_creating.png differ
diff --git a/packages/SystemUI/res/drawable-mdpi/connect_established.png b/packages/SystemUI/res/drawable-mdpi/connect_established.png
new file mode 100755
index 0000000..6c511cb
Binary files /dev/null and b/packages/SystemUI/res/drawable-mdpi/connect_established.png differ
diff --git a/packages/SystemUI/res/drawable-mdpi/connect_no.png b/packages/SystemUI/res/drawable-mdpi/connect_no.png
new file mode 100755
index 0000000..6f56da1
Binary files /dev/null and b/packages/SystemUI/res/drawable-mdpi/connect_no.png differ
diff --git a/packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000..c7cbbf3
Binary files /dev/null and b/packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_connected.png differ
diff --git a/packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000..263fd06
Binary files /dev/null and b/packages/SystemUI/res/drawable-mdpi/stat_sys_ethernet_disconnected.png differ
diff --git a/packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000..01a6203
Binary files /dev/null and b/packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_connected.png differ
diff --git a/packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000..d49161c
Binary files /dev/null and b/packages/SystemUI/res/drawable-sw600dp-hdpi/stat_sys_ethernet_disconnected.png differ
diff --git a/packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000..a671ae0
Binary files /dev/null and b/packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_connected.png differ
diff --git a/packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000..e357d2b
Binary files /dev/null and b/packages/SystemUI/res/drawable-sw600dp-mdpi/stat_sys_ethernet_disconnected.png differ
diff --git a/packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000..3df225b
Binary files /dev/null and b/packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_connected.png differ
diff --git a/packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000..0c2059b
Binary files /dev/null and b/packages/SystemUI/res/drawable-sw600dp-xhdpi/stat_sys_ethernet_disconnected.png differ
diff --git a/packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000..01a6203
Binary files /dev/null and b/packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_connected.png differ
diff --git a/packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000..d49161c
Binary files /dev/null and b/packages/SystemUI/res/drawable-xhdpi/stat_sys_ethernet_disconnected.png differ
diff --git a/packages/SystemUI/res/drawable/stat_sys_ethernet_connected.png b/packages/SystemUI/res/drawable/stat_sys_ethernet_connected.png
new file mode 100644
index 0000000..da4e162
Binary files /dev/null and b/packages/SystemUI/res/drawable/stat_sys_ethernet_connected.png differ
diff --git a/packages/SystemUI/res/drawable/stat_sys_ethernet_disconnected.png b/packages/SystemUI/res/drawable/stat_sys_ethernet_disconnected.png
new file mode 100644
index 0000000..932bac1
Binary files /dev/null and b/packages/SystemUI/res/drawable/stat_sys_ethernet_disconnected.png differ
diff --git a/packages/SystemUI/res/layout/signal_cluster_view.xml b/packages/SystemUI/res/layout/signal_cluster_view.xml
index 66c64c4..3383ed6 100644
--- a/packages/SystemUI/res/layout/signal_cluster_view.xml
+++ b/packages/SystemUI/res/layout/signal_cluster_view.xml
@@ -28,7 +28,6 @@
         android:id="@+id/wifi_combo"
         android:layout_height="wrap_content"
         android:layout_width="wrap_content"
-        android:layout_marginRight="-6dp"
         >
         <ImageView
             android:id="@+id/wifi_signal"
@@ -45,6 +44,33 @@
             android:layout_gravity="center|bottom"
             />
     </FrameLayout>
+    <FrameLayout
+       android:layout_height="wrap_content"
+       android:layout_width="wrap_content"
+       >
+       <View
+            android:layout_height="6dp"
+            android:layout_width="6dp"
+            android:visibility="invisible"
+            />
+        <FrameLayout
+            android:id="@+id/ethernet_combo"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            >
+            <ImageView
+                android:id="@+id/ethernet_status"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                />
+            <ImageView
+                android:id="@+id/ethernet_inout"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_gravity="right|bottom"
+                />
+        </FrameLayout>
+    </FrameLayout>
     <View
         android:layout_height="6dp"
         android:layout_width="6dp"
diff --git a/packages/SystemUI/res/values-en-rGB/strings.xml b/packages/SystemUI/res/values-en-rGB/strings.xml
index 890e05e..23730d6 100644
--- a/packages/SystemUI/res/values-en-rGB/strings.xml
+++ b/packages/SystemUI/res/values-en-rGB/strings.xml
@@ -106,6 +106,8 @@
     <string name="accessibility_wifi_two_bars" msgid="4994274250497262434">"Wifi two bars."</string>
     <string name="accessibility_wifi_three_bars" msgid="3495755044276588384">"Wifi three bars."</string>
     <string name="accessibility_wifi_signal_full" msgid="6853561303586480376">"Wifi signal full."</string>
+    <string name="accessibility_no_ethernet" msgid="1425476551827924475">"Ethernet disconnected."</string>
+    <string name="accessibility_ethernet_connected" msgid="7735893178010724378">"Ethernet connected."</string>
     <string name="accessibility_no_wimax" msgid="4329180129727630368">"No WiMAX."</string>
     <string name="accessibility_wimax_one_bar" msgid="4170994299011863648">"WiMAX one bar."</string>
     <string name="accessibility_wimax_two_bars" msgid="9176236858336502288">"WiMAX two bars."</string>
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java b/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java
index 1321ade..8a3779b 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java
@@ -41,14 +41,16 @@ public class SignalClusterView
 
     private boolean mWifiVisible = false;
     private int mWifiStrengthId = 0, mWifiActivityId = 0;
+    private boolean mEthernetVisible = false;
+    private int mEthernetStatusId = 0, mEthernetActivityId = 0;
     private boolean mMobileVisible = false;
     private int mMobileStrengthId = 0, mMobileActivityId = 0, mMobileTypeId = 0;
     private boolean mIsAirplaneMode = false;
     private int mAirplaneIconId = 0;
-    private String mWifiDescription, mMobileDescription, mMobileTypeDescription;
+    private String mWifiDescription, mEthernetDescription, mMobileDescription, mMobileTypeDescription;
 
-    ViewGroup mWifiGroup, mMobileGroup;
-    ImageView mWifi, mMobile, mWifiActivity, mMobileActivity, mMobileType, mAirplane;
+    ViewGroup mWifiGroup, mEthernetGroup, mMobileGroup;
+    ImageView mWifi, mEthernet, mMobile, mWifiActivity, mEthernetActivity, mMobileActivity, mMobileType, mAirplane;
     View mSpacer;
 
     public SignalClusterView(Context context) {
@@ -75,6 +77,9 @@ public class SignalClusterView
         mWifiGroup      = (ViewGroup) findViewById(R.id.wifi_combo);
         mWifi           = (ImageView) findViewById(R.id.wifi_signal);
         mWifiActivity   = (ImageView) findViewById(R.id.wifi_inout);
+        mEthernetGroup  = (ViewGroup) findViewById(R.id.ethernet_combo);
+        mEthernet       = (ImageView) findViewById(R.id.ethernet_status);
+        mEthernetActivity = (ImageView) findViewById(R.id.ethernet_inout);
         mMobileGroup    = (ViewGroup) findViewById(R.id.mobile_combo);
         mMobile         = (ImageView) findViewById(R.id.mobile_signal);
         mMobileActivity = (ImageView) findViewById(R.id.mobile_inout);
@@ -90,6 +95,9 @@ public class SignalClusterView
         mWifiGroup      = null;
         mWifi           = null;
         mWifiActivity   = null;
+        mEthernetGroup  = null;
+        mEthernet       = null;
+        mEthernetActivity = null;
         mMobileGroup    = null;
         mMobile         = null;
         mMobileActivity = null;
@@ -112,6 +120,17 @@ public class SignalClusterView
     }
 
     @Override
+    public void setEthernetIndicators(boolean visible, int statusIcon, int activityIcon,
+            String contentDescription) {
+        mEthernetVisible = visible;
+        mEthernetStatusId = statusIcon;
+        mEthernetActivityId = activityIcon;
+        mEthernetDescription = contentDescription;
+
+        apply();
+    }
+
+    @Override
     public void setMobileDataIndicators(boolean visible, int strengthIcon, int activityIcon,
             int typeIcon, String contentDescription, String typeContentDescription) {
         mMobileVisible = visible;
@@ -138,6 +157,8 @@ public class SignalClusterView
         // ignore content description, so populate manually
         if (mWifiVisible && mWifiGroup.getContentDescription() != null)
             event.getText().add(mWifiGroup.getContentDescription());
+        if (mEthernetVisible && mEthernetGroup.getContentDescription() != null)
+            event.getText().add(mEthernetGroup.getContentDescription());
         if (mMobileVisible && mMobileGroup.getContentDescription() != null)
             event.getText().add(mMobileGroup.getContentDescription());
         return super.dispatchPopulateAccessibilityEvent(event);
@@ -161,6 +182,20 @@ public class SignalClusterView
                     (mWifiVisible ? "VISIBLE" : "GONE"),
                     mWifiStrengthId, mWifiActivityId));
 
+        if (mEthernetVisible) {
+            mEthernetGroup.setVisibility(View.VISIBLE);
+            mEthernet.setImageResource(mEthernetStatusId);
+            mEthernetActivity.setImageResource(mEthernetActivityId);
+            mEthernetGroup.setContentDescription(mEthernetDescription);
+        } else {
+            mEthernetGroup.setVisibility(View.GONE);
+        }
+
+        if (DEBUG) Slog.d(TAG,
+                String.format("ethernet: %s status=%d act=%d",
+                    (mEthernetVisible ? "VISIBLE" : "GONE"),
+                    mEthernetStatusId, mEthernetActivityId));
+
         if (mMobileVisible && !mIsAirplaneMode) {
             mMobileGroup.setVisibility(View.VISIBLE);
             mMobile.setImageResource(mMobileStrengthId);
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
index 7371ce2..c47a8e1 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
@@ -597,6 +597,12 @@ public class PhoneStatusBar extends BaseStatusBar {
             mClingShown = true;
         }
 
+        final ImageView ethernetStatus =
+            (ImageView)sb.findViewById(R.id.ethernet_status);
+               if (ethernetStatus != null) {
+                   mNetworkController.addEthernetIconView(ethernetStatus);
+	       }
+
 //        final ImageView wimaxRSSI =
 //                (ImageView)sb.findViewById(R.id.wimax_signal);
 //        if (wimaxRSSI != null) {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/AccessibilityContentDescriptions.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/AccessibilityContentDescriptions.java
index 7ac2a98..9273433 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/policy/AccessibilityContentDescriptions.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/AccessibilityContentDescriptions.java
@@ -33,6 +33,10 @@ public class AccessibilityContentDescriptions {
         R.string.accessibility_wifi_three_bars,
         R.string.accessibility_wifi_signal_full
     };
+    static final int[] ETHERNET_CONNECTION_STATUS = {
+        R.string.accessibility_no_ethernet,
+        R.string.accessibility_ethernet_connected
+    };
     static final int[] WIMAX_CONNECTION_STRENGTH = {
         R.string.accessibility_no_wimax,
         R.string.accessibility_wimax_one_bar,
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/EthernetIcons.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/EthernetIcons.java
new file mode 100644
index 0000000..40f5563
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/EthernetIcons.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar.policy;
+
+import com.android.systemui.R;
+
+class EthernetIcons {
+
+    static final int[] ETHERNET_STATUS = {
+	R.drawable.stat_sys_ethernet_disconnected,
+	R.drawable.stat_sys_ethernet_connected,
+        R.drawable.connect_no,
+        R.drawable.connect_creating,
+        R.drawable.connect_established
+    };
+
+    static final int ETHERNET_DISCONNECTED = ETHERNET_STATUS[0];
+
+    static final int ETHERNET_CONNECTED = ETHERNET_STATUS[1];
+}
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
index bbb90c8..0d9d7ad 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
@@ -26,6 +26,8 @@ import android.net.NetworkInfo;
 import android.net.wifi.WifiConfiguration;
 import android.net.wifi.WifiInfo;
 import android.net.wifi.WifiManager;
+import android.net.ethernet.EthernetManager;
+import android.net.ethernet.EthernetStateTracker;
 import android.net.wimax.WimaxManagerConstants;
 import android.os.Binder;
 import android.os.Handler;
@@ -92,6 +94,7 @@ public class NetworkController extends BroadcastReceiver {
 
     String mContentDescriptionPhoneSignal;
     String mContentDescriptionWifi;
+    String mContentDescriptionEthernet;
     String mContentDescriptionWimax;
     String mContentDescriptionCombinedSignal;
     String mContentDescriptionDataType;
@@ -107,6 +110,12 @@ public class NetworkController extends BroadcastReceiver {
     int mWifiActivityIconId = 0; // overlay arrows for wifi direction
     int mWifiActivity = WifiManager.DATA_ACTIVITY_NONE;
 
+    // ethernet
+    boolean mEthernetEnabled, mEthernetConnected, mHasEthernet;
+    int mEthernetIconId = 0;
+    int mEthernetActivityIconId = 0;
+    int mEthernetActivity = EthernetManager.DATA_ACTIVITY_NONE;
+
     // bluetooth
     private boolean mBluetoothTethered = false;
     private int mBluetoothTetherIconId =
@@ -139,6 +148,7 @@ public class NetworkController extends BroadcastReceiver {
     ArrayList<ImageView> mDataDirectionIconViews = new ArrayList<ImageView>();
     ArrayList<ImageView> mDataDirectionOverlayIconViews = new ArrayList<ImageView>();
     ArrayList<ImageView> mWifiIconViews = new ArrayList<ImageView>();
+    ArrayList<ImageView> mEthernetIconViews = new ArrayList<ImageView>();
     ArrayList<ImageView> mWimaxIconViews = new ArrayList<ImageView>();
     ArrayList<ImageView> mCombinedSignalIconViews = new ArrayList<ImageView>();
     ArrayList<ImageView> mDataTypeIconViews = new ArrayList<ImageView>();
@@ -153,6 +163,7 @@ public class NetworkController extends BroadcastReceiver {
     int mLastDataDirectionIconId = -1;
     int mLastDataDirectionOverlayIconId = -1;
     int mLastWifiIconId = -1;
+    int mLastEthernetIconId = -1;
     int mLastWimaxIconId = -1;
     int mLastCombinedSignalIconId = -1;
     int mLastDataTypeIconId = -1;
@@ -168,6 +179,8 @@ public class NetworkController extends BroadcastReceiver {
     public interface SignalCluster {
         void setWifiIndicators(boolean visible, int strengthIcon, int activityIcon,
                 String contentDescription);
+        void setEthernetIndicators(boolean visible, int statusIcon, int activityIcon,
+                String contentDescription);
         void setMobileDataIndicators(boolean visible, int strengthIcon, int activityIcon,
                 int typeIcon, String contentDescription, String typeContentDescription);
         void setIsAirplaneMode(boolean is, int airplaneIcon);
@@ -191,6 +204,7 @@ public class NetworkController extends BroadcastReceiver {
 
         ConnectivityManager cm = (ConnectivityManager)mContext.getSystemService(
                 Context.CONNECTIVITY_SERVICE);
+	mHasEthernet = cm.isNetworkSupported(ConnectivityManager.TYPE_ETHERNET);
         mHasMobileDataFeature = cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
 
         mShowPhoneRSSIForData = res.getBoolean(R.bool.config_showPhoneRSSIForData);
@@ -200,6 +214,7 @@ public class NetworkController extends BroadcastReceiver {
 
         // set up the default wifi icon, used when no radios have ever appeared
         updateWifiIcons();
+        updateEthernetIcons();
         updateWimaxIcons();
 
         // telephony
@@ -231,6 +246,7 @@ public class NetworkController extends BroadcastReceiver {
         filter.addAction(WifiManager.RSSI_CHANGED_ACTION);
         filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
         filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
+	filter.addAction(EthernetManager.ETHERNET_STATE_CHANGED_ACTION);
         filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
         filter.addAction(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
         filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
@@ -276,6 +292,9 @@ public class NetworkController extends BroadcastReceiver {
     public void addWifiIconView(ImageView v) {
         mWifiIconViews.add(v);
     }
+    public void addEthernetIconView(ImageView v) {
+        mEthernetIconViews.add(v);
+    }
     public void addWimaxIconView(ImageView v) {
         mWimaxIconViews.add(v);
     }
@@ -322,6 +341,13 @@ public class NetworkController extends BroadcastReceiver {
                 mWifiActivityIconId,
                 mContentDescriptionWifi);
 
+        cluster.setEthernetIndicators(
+                // only show ethernet in the cluster if connected
+                mEthernetEnabled && mEthernetConnected,
+                mEthernetIconId,
+                mEthernetActivityIconId,
+                mContentDescriptionEthernet);
+
         if (mIsWimaxEnabled && mWimaxConnected) {
             // wimax is special
             cluster.setMobileDataIndicators(
@@ -383,6 +409,9 @@ public class NetworkController extends BroadcastReceiver {
                 || action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
             updateWifiState(intent);
             refreshViews();
+        } else if (action.equals(EthernetManager.ETHERNET_STATE_CHANGED_ACTION)) { 
+            updateEthernetState(intent);
+            refreshViews();
         } else if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
             updateSimState(intent);
             updateDataIcon();
@@ -901,6 +930,32 @@ public class NetworkController extends BroadcastReceiver {
     }
 
 
+    // ===== Ethernet ================================================================
+
+    private void updateEthernetState(Intent intent) {
+        final String action = intent.getAction();
+        if (action.equals(EthernetManager.ETHERNET_STATE_CHANGED_ACTION)) {
+            mEthernetEnabled = intent.getIntExtra(EthernetManager.EXTRA_ETHERNET_STATE, EthernetManager.ETHERNET_STATE_UNKNOWN) == EthernetManager.ETHERNET_STATE_ENABLED;
+	}
+
+	updateEthernetIcons();
+
+	final int event = intent.getIntExtra(EthernetManager.EXTRA_ETHERNET_STATE, EthernetManager.ETHERNET_STATE_UNKNOWN);
+        switch (event) {
+	    case EthernetStateTracker.EVENT_HW_CONNECTED:
+            case EthernetStateTracker.EVENT_INTERFACE_CONFIGURATION_SUCCEEDED:
+                mEthernetIconId = EthernetIcons.ETHERNET_STATUS[5];
+                break;
+            case EthernetStateTracker.EVENT_HW_DISCONNECTED:
+            case EthernetStateTracker.EVENT_INTERFACE_CONFIGURATION_FAILED:
+                mEthernetIconId = EthernetIcons.ETHERNET_STATUS[3];
+                break;
+            default:
+                mEthernetIconId = EthernetIcons.ETHERNET_STATUS[4];
+		break;
+	}
+    }
+
     // ===== Wimax ===================================================================
     private final void updateWimaxState(Intent intent) {
         final String action = intent.getAction();
@@ -986,6 +1041,7 @@ public class NetworkController extends BroadcastReceiver {
         updateDataIcon();
         updateTelephonySignalStrength();
         updateWifiIcons();
+        updateEthernetIcons();
     }
 
 
@@ -1102,8 +1158,10 @@ public class NetworkController extends BroadcastReceiver {
         }
 
         final boolean ethernetConnected = (mConnectedNetworkType == ConnectivityManager.TYPE_ETHERNET);
-        if (ethernetConnected) {
+        if (ethernetConnected || mEthernetConnected) {
             combinedLabel = context.getString(R.string.ethernet_label);
+	    combinedActivityIconId = 0;
+	    combinedSignalIconId = mEthernetIconId; 
         }
 
         if (mAirplaneMode &&
@@ -1133,7 +1191,7 @@ public class NetworkController extends BroadcastReceiver {
                 combinedSignalIconId = mDataSignalIconId;
             }
         }
-        else if (!mDataConnected && !mWifiConnected && !mBluetoothTethered && !mWimaxConnected && !ethernetConnected) {
+        else if (!mDataConnected && !mWifiConnected && !mBluetoothTethered && !mWimaxConnected && !ethernetConnected && !mEthernetConnected) {
             // pretty much totally disconnected
 
             combinedLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
@@ -1159,6 +1217,7 @@ public class NetworkController extends BroadcastReceiver {
         if (DEBUG) {
             Slog.d(TAG, "refreshViews connected={"
                     + (mWifiConnected?" wifi":"")
+                    + (mEthernetConnected?" ethernet":"")
                     + (mDataConnected?" data":"")
                     + " } level="
                     + ((mSignalStrength == null)?"??":Integer.toString(mSignalStrength.getLevel()))
@@ -1179,6 +1238,7 @@ public class NetworkController extends BroadcastReceiver {
                     + " mDataTypeIconId=0x" + Integer.toHexString(mDataTypeIconId)
                     + " mQSDataTypeIconId=0x" + Integer.toHexString(mQSDataTypeIconId)
                     + " mWifiIconId=0x" + Integer.toHexString(mWifiIconId)
+                    + " mEthernetIconId=0x" + Integer.toHexString(mEthernetIconId)
                     + " mQSWifiIconId=0x" + Integer.toHexString(mQSWifiIconId)
                     + " mBluetoothTetherIconId=0x" + Integer.toHexString(mBluetoothTetherIconId));
         }
@@ -1186,6 +1246,7 @@ public class NetworkController extends BroadcastReceiver {
         if (mLastPhoneSignalIconId          != mPhoneSignalIconId
          || mLastDataDirectionOverlayIconId != combinedActivityIconId
          || mLastWifiIconId                 != mWifiIconId
+         || mLastEthernetIconId             != mEthernetIconId
          || mLastWimaxIconId                != mWimaxIconId
          || mLastDataTypeIconId             != mDataTypeIconId
          || mLastAirplaneMode               != mAirplaneMode)
@@ -1246,6 +1307,22 @@ public class NetworkController extends BroadcastReceiver {
             }
         }
 
+        // the Ethernet icon
+        if (mLastEthernetIconId != mEthernetIconId) {
+            mLastEthernetIconId = mEthernetIconId;
+            N = mEthernetIconViews.size();
+            for (int i=0; i<N; i++) {
+                final ImageView v = mEthernetIconViews.get(i);
+                if (mEthernetIconId == 0) {
+                    v.setVisibility(View.INVISIBLE);
+                } else {
+                    v.setVisibility(View.VISIBLE);
+                    v.setImageResource(mEthernetIconId);
+                    v.setContentDescription(mContentDescriptionEthernet);
+                }
+            }
+        }
+
         // the wimax icon on phones
         if (mLastWimaxIconId != mWimaxIconId) {
             mLastWimaxIconId = mWimaxIconId;
@@ -1432,6 +1509,10 @@ public class NetworkController extends BroadcastReceiver {
         pw.print("  mWifiActivity=");
         pw.println(mWifiActivity);
 
+	pw.println("  - ethernet ------");
+	pw.print("  mEthernetConnected=");
+	pw.println(mEthernetConnected);
+
         if (mWimaxSupported) {
             pw.println("  - wimax ------");
             pw.print("  mIsWimaxEnabled="); pw.println(mIsWimaxEnabled);
diff --git a/services/java/com/android/server/ConnectivityService.java b/services/java/com/android/server/ConnectivityService.java
index ad1dfb2..592a99f 100644
--- a/services/java/com/android/server/ConnectivityService.java
+++ b/services/java/com/android/server/ConnectivityService.java
@@ -46,7 +46,6 @@ import android.database.ContentObserver;
 import android.net.CaptivePortalTracker;
 import android.net.ConnectivityManager;
 import android.net.DummyDataStateTracker;
-import android.net.EthernetDataTracker;
 import android.net.IConnectivityManager;
 import android.net.INetworkManagementEventObserver;
 import android.net.INetworkPolicyListener;
@@ -67,6 +66,7 @@ import android.net.Proxy;
 import android.net.ProxyProperties;
 import android.net.RouteInfo;
 import android.net.wifi.WifiStateTracker;
+import android.net.ethernet.EthernetStateTracker;
 import android.net.wimax.WimaxManagerConstants;
 import android.os.Binder;
 import android.os.FileUtils;
@@ -449,7 +449,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                             n.type);
                     continue;
                 }
-                if (mRadioAttributes[n.radio] == null) {
+                if ((n.type != ConnectivityManager.TYPE_ETHERNET) && mRadioAttributes[n.radio] == null) {
                     loge("Error in networkAttributes - ignoring attempt to use undefined " +
                             "radio " + n.radio + " in network type " + n.type);
                     continue;
@@ -529,6 +529,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         mTethering = new Tethering(mContext, mNetd, statsService, this, mHandler.getLooper());
         mTetheringConfigValid = ((mTethering.getTetherableUsbRegexs().length != 0 ||
                                   mTethering.getTetherableWifiRegexs().length != 0 ||
+                                  mTethering.getTetherableEthernetRegexs().length != 0 ||
                                   mTethering.getTetherableBluetoothRegexs().length != 0) &&
                                  mTethering.getUpstreamIfaceTypes().length != 0);
 
@@ -575,6 +576,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             switch (config.radio) {
                 case TYPE_WIFI:
                     return new WifiStateTracker(targetNetworkType, config.name);
+                case TYPE_ETHERNET:
+                    return new EthernetStateTracker(targetNetworkType, config.name);
                 case TYPE_MOBILE:
                     return new MobileDataStateTracker(targetNetworkType, config.name);
                 case TYPE_DUMMY:
@@ -583,8 +586,6 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                     return BluetoothTetheringDataTracker.getInstance();
                 case TYPE_WIMAX:
                     return makeWimaxStateTracker(mContext, mTrackerHandler);
-                case TYPE_ETHERNET:
-                    return EthernetDataTracker.getInstance();
                 default:
                     throw new IllegalArgumentException(
                             "Trying to create a NetworkStateTracker for an unknown radio type: "
@@ -2346,7 +2347,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
 
    /**
      * Reads the network specific TCP buffer sizes from SystemProperties
-     * net.tcp.buffersize.[default|wifi|umts|edge|gprs] and set them for system
+     * net.tcp.buffersize.[default|wifi|ethernet|umts|edge|gprs] and set them for system
      * wide use
      */
    public void updateNetworkSettings(NetworkStateTracker nt) {
@@ -2883,6 +2884,15 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         }
     }
 
+    public String[] getTetherableEthernetRegexs() {
+        enforceTetherAccessPermission();
+        if (isTetheringSupported()) {
+            return mTethering.getTetherableEthernetRegexs();
+        } else {
+            return new String[0];
+        }
+    }
+
     public String[] getTetherableBluetoothRegexs() {
         enforceTetherAccessPermission();
         if (isTetheringSupported()) {
diff --git a/services/java/com/android/server/EthernetService.java b/services/java/com/android/server/EthernetService.java
new file mode 100644
index 0000000..244bd71
--- /dev/null
+++ b/services/java/com/android/server/EthernetService.java
@@ -0,0 +1,1237 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import android.app.ActivityManager;
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.app.TaskStackBuilder;
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.database.ContentObserver;
+import android.net.ethernet.IEthernetManager;
+import android.net.ethernet.EthernetInfo;
+import android.net.ethernet.EthernetManager;
+import android.net.ethernet.EthernetStateMachine;
+import android.net.ethernet.EthernetConfiguration;
+import android.net.ConnectivityManager;
+import android.net.DhcpInfo;
+import android.net.NetworkInfo;
+import android.net.NetworkInfo.State;
+import android.net.NetworkInfo.DetailedState;
+import android.net.TrafficStats;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.Messenger;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.INetworkManagementService;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.os.WorkSource;
+import android.provider.Settings;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.Slog;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+
+import com.android.internal.app.IBatteryStats;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.util.AsyncChannel;
+import com.android.server.am.BatteryStatsService;
+import com.android.internal.R;
+
+/**
+ * EthernetService handles remote Ethernet operation requests by implementing
+ * the IEthernetManager interface.
+ *
+ * @hide
+ */
+public class EthernetService extends IEthernetManager.Stub {
+    private static final String TAG = "EthernetService";
+    private static final boolean DBG = false;
+
+    private final EthernetStateMachine mEthernetStateMachine;
+
+    private Context mContext;
+
+    private AlarmManager mAlarmManager;
+    private PendingIntent mIdleIntent;
+    private static final int IDLE_REQUEST = 0;
+    private boolean mScreenOff;
+    private boolean mDeviceIdle;
+    private boolean mEmergencyCallbackMode = false;
+    private int mPluggedType;
+
+    private final LockList mLocks = new LockList();
+    // some ethernet lock statistics
+    private int mFullHighPerfLocksAcquired;
+    private int mFullHighPerfLocksReleased;
+    private int mFullLocksAcquired;
+    private int mFullLocksReleased;
+    private int mRestrictedFeLocksAcquired;
+    private int mRestrictedFeLocksReleased;
+
+    private final List<Multicaster> mMulticasters =
+            new ArrayList<Multicaster>();
+    private int mMulticastEnabled;
+    private int mMulticastDisabled;
+
+    private final IBatteryStats mBatteryStats;
+
+    private boolean mEnableTrafficStatsPoll = false;
+    private int mTrafficStatsPollToken = 0;
+    private long mTxPkts;
+    private long mRxPkts;
+    /* Tracks last reported data activity */
+    private int mDataActivity;
+    private String mInterfaceName;
+
+    /**
+     * Interval in milliseconds between polling for traffic
+     * statistics
+     */
+    private static final int POLL_TRAFFIC_STATS_INTERVAL_MSECS = 1000;
+
+    /**
+     * See {@link Settings.Global#ETHERNET_IDLE_MS}. This is the default value if a
+     * Settings.Global value is not present. This timeout value is chosen as
+     * the approximate point at which the battery drain caused by Wi-Fi
+     * being enabled but not active exceeds the battery drain caused by
+     * re-establishing a connection to the mobile data network.
+     */
+    private static final long DEFAULT_IDLE_MS = 15 * 60 * 1000; /* 15 minutes */
+
+    private static final String ACTION_DEVICE_IDLE =
+            "com.android.server.EthernetManager.action.DEVICE_IDLE";
+
+    private static final int ETHERNET_DISABLED                  = 0;
+    private static final int ETHERNET_ENABLED                   = 1;
+
+    /* Persisted state that tracks the ethernet interaction from settings */
+    private AtomicInteger mPersistEthernetState = new AtomicInteger(ETHERNET_DISABLED);
+    /* Tracks whether ethernet is enabled from EthernetStateMachine's perspective */
+    private boolean mEthernetEnabled;
+
+    private boolean mIsReceiverRegistered = false;
+
+
+    NetworkInfo mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_ETHERNET, 0, "ETHERNET", "");
+
+    /**
+     * Asynchronous channel to EthernetStateMachine
+     */
+    private AsyncChannel mEthernetStateMachineChannel;
+
+    /**
+     * Clients receiving asynchronous messages
+     */
+    private List<AsyncChannel> mClients = new ArrayList<AsyncChannel>();
+
+    /**
+     * Handles client connections
+     */
+    private class AsyncServiceHandler extends Handler {
+
+        AsyncServiceHandler(android.os.Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case EthernetManager.ENABLE_TRAFFIC_STATS_POLL: {
+                    mEnableTrafficStatsPoll = (msg.arg1 == 1);
+                    mTrafficStatsPollToken++;
+                    if (mEnableTrafficStatsPoll) {
+                        notifyOnDataActivity();
+                        sendMessageDelayed(Message.obtain(this, EthernetManager.TRAFFIC_STATS_POLL,
+                                mTrafficStatsPollToken, 0), POLL_TRAFFIC_STATS_INTERVAL_MSECS);
+                    }
+                    break;
+                }
+                case EthernetManager.TRAFFIC_STATS_POLL: {
+                    if (msg.arg1 == mTrafficStatsPollToken) {
+                        notifyOnDataActivity();
+                        sendMessageDelayed(Message.obtain(this, EthernetManager.TRAFFIC_STATS_POLL,
+                                mTrafficStatsPollToken, 0), POLL_TRAFFIC_STATS_INTERVAL_MSECS);
+                    }
+                    break;
+                }
+                case EthernetManager.CONNECT_NETWORK: {
+                    mEthernetStateMachine.sendMessage(Message.obtain(msg));
+                    break;
+                }
+                case EthernetManager.SAVE_NETWORK: {
+                    mEthernetStateMachine.sendMessage(Message.obtain(msg));
+                    break;
+                }
+                case EthernetManager.FORGET_NETWORK: {
+                    mEthernetStateMachine.sendMessage(Message.obtain(msg));
+                    break;
+                }
+                case EthernetManager.DISABLE_NETWORK: {
+                    mEthernetStateMachine.sendMessage(Message.obtain(msg));
+                    break;
+                }
+                default: {
+                    Slog.d(TAG, "EthernetServicehandler.handleMessage ignoring msg=" + msg);
+                    break;
+                }
+            }
+        }
+    }
+    private AsyncServiceHandler mAsyncServiceHandler;
+
+    /**
+     * Handles interaction with EthernetStateMachine
+     */
+    private class EthernetStateMachineHandler extends Handler {
+        private AsyncChannel mWsmChannel;
+
+        EthernetStateMachineHandler(android.os.Looper looper) {
+            super(looper);
+            mWsmChannel = new AsyncChannel();
+            mWsmChannel.connect(mContext, this, mEthernetStateMachine.getHandler());
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                default: {
+                    Slog.d(TAG, "EthernetStateMachineHandler.handleMessage ignoring msg=" + msg);
+                    break;
+                }
+            }
+        }
+    }
+    EthernetStateMachineHandler mEthernetStateMachineHandler;
+
+    /**
+     * Temporary for computing UIDS that are responsible for starting ETHERNET.
+     * Protected by mEthernetStateTracker lock.
+     */
+    private final WorkSource mTmpWorkSource = new WorkSource();
+
+    EthernetService(Context context) {
+        mContext = context;
+
+        mInterfaceName =  SystemProperties.get("ethernet.interface", "eth0");
+
+        mEthernetStateMachine = new EthernetStateMachine(mContext, mInterfaceName);
+        mBatteryStats = BatteryStatsService.getService();
+
+        mAlarmManager = (AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
+        Intent idleIntent = new Intent(ACTION_DEVICE_IDLE, null);
+        mIdleIntent = PendingIntent.getBroadcast(mContext, IDLE_REQUEST, idleIntent, 0);
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(EthernetManager.ETHERNET_STATE_CHANGED_ACTION);
+        filter.addAction(EthernetManager.NETWORK_STATE_CHANGED_ACTION);
+
+        mContext.registerReceiver(
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                        if (intent.getAction().equals(EthernetManager.ETHERNET_STATE_CHANGED_ACTION)) {
+                            int ethernetState = intent.getIntExtra(EthernetManager.EXTRA_ETHERNET_STATE,
+                                    EthernetManager.ETHERNET_STATE_DISABLED);
+
+                            mEthernetEnabled = (ethernetState == EthernetManager.ETHERNET_STATE_ENABLED);
+
+                        } else if (intent.getAction().equals(
+                                EthernetManager.NETWORK_STATE_CHANGED_ACTION)) {
+                            mNetworkInfo = (NetworkInfo) intent.getParcelableExtra(
+                                    EthernetManager.EXTRA_NETWORK_INFO);
+                            switch(mNetworkInfo.getDetailedState()) {
+                                case CONNECTED:
+                                case DISCONNECTED:
+                                case CAPTIVE_PORTAL_CHECK:
+                                    evaluateTrafficStatsPolling();
+                                    break;
+                            }
+                        }
+                    }
+                }, filter);
+
+        HandlerThread ethernetThread = new HandlerThread("EthernetService");
+        ethernetThread.start();
+        mAsyncServiceHandler = new AsyncServiceHandler(ethernetThread.getLooper());
+        mEthernetStateMachineHandler = new EthernetStateMachineHandler(ethernetThread.getLooper());
+    }
+
+    /**
+     * Check if Ethernet needs to be enabled and start
+     * if needed
+     *
+     * This function is used only at boot time
+     */
+    public void checkAndStartEthernet() {
+        mPersistEthernetState.set(getPersistedEthernetState());
+        /* Start if Ethernet should be enabled or the saved state indicates Ethernet was on */
+        boolean ethernetEnabled = shouldEthernetBeEnabled() || testAndClearEthernetSavedState();
+        Slog.i(TAG, "EthernetService starting up with Ethernet " +
+                (ethernetEnabled ? "enabled" : "disabled"));
+
+        // If we are already disabled, avoid changing persist state here
+        if (ethernetEnabled) setEthernetEnabled(ethernetEnabled);
+    }
+
+    private boolean testAndClearEthernetSavedState() {
+        final ContentResolver cr = mContext.getContentResolver();
+        int ethernetSavedState = 0;
+        try {
+            ethernetSavedState = Settings.Global.getInt(cr, Settings.Global.ETHERNET_SAVED_STATE);
+            if(ethernetSavedState == 1)
+                Settings.Global.putInt(cr, Settings.Global.ETHERNET_SAVED_STATE, 0);
+        } catch (Settings.SettingNotFoundException e) {
+            ;
+        }
+        return (ethernetSavedState == 1);
+    }
+
+    private int getPersistedEthernetState() {
+        final ContentResolver cr = mContext.getContentResolver();
+        try {
+            return Settings.Global.getInt(cr, Settings.Global.ETHERNET_ON);
+        } catch (Settings.SettingNotFoundException e) {
+            Settings.Global.putInt(cr, Settings.Global.ETHERNET_ON, ETHERNET_DISABLED);
+            return ETHERNET_DISABLED;
+        }
+    }
+
+    private boolean shouldEthernetBeEnabled() {
+	return mPersistEthernetState.get() != ETHERNET_DISABLED;
+    }
+
+    private void handleEthernetToggled(boolean ethernetEnabled) {
+        if (ethernetEnabled) {
+	    persistEthernetState(ETHERNET_ENABLED);
+        } else {
+            persistEthernetState(ETHERNET_DISABLED);
+        }
+    }
+
+    private void persistEthernetState(int state) {
+        final ContentResolver cr = mContext.getContentResolver();
+        mPersistEthernetState.set(state);
+        Settings.Global.putInt(cr, Settings.Global.ETHERNET_ON, state);
+    }
+
+    private void enforceAccessPermission() {
+        mContext.enforceCallingOrSelfPermission(
+		android.Manifest.permission.ACCESS_ETHERNET_STATE,
+		"EthernetService");
+    }
+
+    private void enforceChangePermission() {
+        mContext.enforceCallingOrSelfPermission(
+		android.Manifest.permission.CHANGE_ETHERNET_STATE,
+		"EthernetService");
+    }
+
+    private void enforceMulticastChangePermission() {
+        mContext.enforceCallingOrSelfPermission(
+                android.Manifest.permission.CHANGE_ETHERNET_MULTICAST_STATE,
+                "EthernetService");
+    }
+
+    private void enforceConnectivityInternalPermission() {
+        mContext.enforceCallingOrSelfPermission(
+                android.Manifest.permission.CONNECTIVITY_INTERNAL,
+                "ConnectivityService");
+    }
+
+    /**
+     * see {@link android.net.ethernet.EthernetManager#setEthernetEnabled(boolean)}
+     * @param enable {@code true} to enable, {@code false} to disable.
+     * @return {@code true} if the enable/disable operation was
+     *         started or is already in the queue.
+     */
+    public synchronized boolean setEthernetEnabled(boolean enable) {
+        enforceChangePermission();
+        Slog.d(TAG, "setEthernetEnabled: " + enable + " pid=" + Binder.getCallingPid()
+                    + ", uid=" + Binder.getCallingUid());
+        if (DBG) {
+            Slog.e(TAG, "Invoking mEthernetStateMachine.setEthernetEnabled\n");
+        }
+
+        if (enable) {
+            reportStartWorkSource();
+        }
+        mEthernetStateMachine.setEthernetEnabled(enable);
+
+        /*
+         * Caller might not have WRITE_SECURE_SETTINGS,
+         * only CHANGE_ETHERNET_STATE is enforced
+         */
+
+        long ident = Binder.clearCallingIdentity();
+        try {
+            handleEthernetToggled(enable);
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+
+        if (enable) {
+            if (!mIsReceiverRegistered) {
+                registerForBroadcasts();
+                mIsReceiverRegistered = true;
+            }
+        } else if (mIsReceiverRegistered) {
+            mContext.unregisterReceiver(mReceiver);
+            mIsReceiverRegistered = false;
+        }
+
+        return true;
+    }
+
+    /**
+     * see {@link EthernetManager#getEthernetState()}
+     * @return One of {@link EthernetManager#ETHERNET_STATE_DISABLED},
+     *         {@link EthernetManager#ETHERNET_STATE_DISABLING},
+     *         {@link EthernetManager#ETHERNET_STATE_ENABLED},
+     *         {@link EthernetManager#ETHERNET_STATE_ENABLING},
+     *         {@link EthernetManager#ETHERNET_STATE_UNKNOWN}
+     */
+    public int getEthernetEnabledState() {
+        enforceAccessPermission();
+        return mEthernetStateMachine.syncGetEthernetState();
+    }
+
+    /**
+     * see {@link android.net.ethernet.EthernetManager#disconnect()}
+     */
+    public void disconnect() {
+        enforceChangePermission();
+        mEthernetStateMachine.disconnectCommand();
+    }
+
+    /**
+     * see {@link android.net.ethernet.EthernetManager#reconnect()}
+     */
+    public void reconnect() {
+        enforceChangePermission();
+        mEthernetStateMachine.reconnectCommand();
+    }
+
+    /**
+     * see {@link android.net.ethernet.EthernetManager#getConfiguredNetworks()}
+     * @return the list of configured networks
+     */
+    public List<EthernetConfiguration> getConfiguredNetworks() {
+        enforceAccessPermission();
+        if (mEthernetStateMachineChannel != null) {
+            return mEthernetStateMachine.syncGetConfiguredNetworks(mEthernetStateMachineChannel);
+        } else {
+            Slog.e(TAG, "mEthernetStateMachineChannel is not initialized");
+            return null;
+        }
+    }
+
+    /**
+     * see {@link android.net.ethernet.EthernetManager#addOrUpdateNetwork(EthernetConfiguration)}
+     * @return the identifier for the new or updated
+     * network if the operation succeeds, or {@code -1} if it fails
+     */
+    public int addOrUpdateNetwork(EthernetConfiguration config) {
+        enforceChangePermission();
+        if (mEthernetStateMachineChannel != null) {
+            return mEthernetStateMachine.syncAddOrUpdateNetwork(mEthernetStateMachineChannel, config);
+        } else {
+            Slog.e(TAG, "mEthernetStateMachineChannel is not initialized");
+            return -1;
+        }
+    }
+
+     /**
+     * See {@link android.net.ethernet.EthernetManager#removeNetwork(int)}
+     * @param netId the integer that identifies the network configuration
+     * to the supplicant
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean removeNetwork(int netId) {
+        enforceChangePermission();
+        if (mEthernetStateMachineChannel != null) {
+            return mEthernetStateMachine.syncRemoveNetwork(mEthernetStateMachineChannel, netId);
+        } else {
+            Slog.e(TAG, "mEthernetStateMachineChannel is not initialized");
+            return false;
+        }
+    }
+
+    /**
+     * See {@link android.net.ethernet.EthernetManager#enableNetwork(int, boolean)}
+     * @param netId the integer that identifies the network configuration
+     * @param disableOthers if true, disable all other networks.
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean enableNetwork(int netId, boolean disableOthers) {
+        enforceChangePermission();
+        if (mEthernetStateMachineChannel != null) {
+            return mEthernetStateMachine.syncEnableNetwork(mEthernetStateMachineChannel, netId,
+                    disableOthers);
+        } else {
+            Slog.e(TAG, "mEthernetStateMachineChannel is not initialized");
+            return false;
+        }
+    }
+
+    /**
+     * See {@link android.net.ethernet.EthernetManager#disableNetwork(int)}
+     * @param netId the integer that identifies the network configuration
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean disableNetwork(int netId) {
+        enforceChangePermission();
+        if (mEthernetStateMachineChannel != null) {
+            return mEthernetStateMachine.syncDisableNetwork(mEthernetStateMachineChannel, netId);
+        } else {
+            Slog.e(TAG, "mEthernetStateMachineChannel is not initialized");
+            return false;
+        }
+    }
+
+    /**
+     * See {@link android.net.ethernet.EthernetManager#getConnectionInfo()}
+     * @return the Ethernet information, contained in {@link EthernetInfo}.
+     */
+    public EthernetInfo getConnectionInfo() {
+        enforceAccessPermission();
+        /*
+         * Make sure we have the latest information
+         */
+        return mEthernetStateMachine.syncRequestConnectionInfo();
+    }
+
+    /**
+     * Persist the current list of configured networks.
+     * @return {@code true} if the operation succeeded
+     *
+     * TODO: deprecate this
+     */
+    public boolean saveConfiguration() {
+        boolean result = true;
+        enforceChangePermission();
+        if (mEthernetStateMachineChannel != null) {
+            return mEthernetStateMachine.syncSaveConfig(mEthernetStateMachineChannel);
+        } else {
+            Slog.e(TAG, "mEthernetStateMachineChannel is not initialized");
+            return false;
+        }
+    }
+
+    /**
+     * Return the DHCP-assigned addresses from the last successful DHCP request,
+     * if any.
+     * @return the DHCP information
+     */
+    public DhcpInfo getDhcpInfo() {
+        enforceAccessPermission();
+        return mEthernetStateMachine.syncGetDhcpInfo();
+    }
+
+    /**
+     * see {@link android.net.ethernet.EthernetManager#startEthernet}
+     *
+     */
+    public void startEthernet() {
+        enforceConnectivityInternalPermission();
+        /* TODO: may be add permissions for access only to connectivity service
+         * TODO: if a start issued, keep ethernet alive until a stop issued irrespective
+         * of EthernetLock & device idle status unless ethernet enabled status is toggled
+         */
+
+        mEthernetStateMachine.setDriverStart(true, mEmergencyCallbackMode);
+        mEthernetStateMachine.reconnectCommand();
+    }
+
+    public void captivePortalCheckComplete() {
+        enforceConnectivityInternalPermission();
+        mEthernetStateMachine.captivePortalCheckComplete();
+    }
+
+    /**
+     * see {@link android.net.ethernet.EthernetManager#stopEthernet}
+     *
+     */
+    public void stopEthernet() {
+        enforceConnectivityInternalPermission();
+        /*
+         * TODO: if a stop is issued, ethernet is brought up only by startEthernet
+         * unless ethernet enabled status is toggled
+         */
+        mEthernetStateMachine.setDriverStart(false, mEmergencyCallbackMode);
+    }
+
+    /**
+     * Get a reference to handler. This is used by a client to establish
+     * an AsyncChannel communication with EthernetService
+     */
+    public Messenger getEthernetServiceMessenger() {
+        enforceAccessPermission();
+        enforceChangePermission();
+        return new Messenger(mAsyncServiceHandler);
+    }
+
+    /** Get a reference to EthernetStateMachine handler for AsyncChannel communication */
+    public Messenger getEthernetStateMachineMessenger() {
+        enforceAccessPermission();
+        enforceChangePermission();
+        return mEthernetStateMachine.getMessenger();
+    }
+
+    /**
+     * Get the IP and proxy configuration file
+     */
+    public String getConfigFile() {
+        enforceAccessPermission();
+        return mEthernetStateMachine.getConfigFile();
+    }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+
+            long idleMillis =
+                Settings.Global.getLong(mContext.getContentResolver(),
+                                        Settings.Global.ETHERNET_IDLE_MS, DEFAULT_IDLE_MS);
+            int stayAwakeConditions =
+                Settings.Global.getInt(mContext.getContentResolver(),
+                                       Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0);
+            if (action.equals(Intent.ACTION_SCREEN_ON)) {
+                if (DBG) {
+                    Slog.d(TAG, "ACTION_SCREEN_ON");
+                }
+                mAlarmManager.cancel(mIdleIntent);
+                mScreenOff = false;
+                evaluateTrafficStatsPolling();
+                setDeviceIdleAndUpdateEthernet(false);
+            } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
+                if (DBG) {
+                    Slog.d(TAG, "ACTION_SCREEN_OFF");
+                }
+                mScreenOff = true;
+                evaluateTrafficStatsPolling();
+                /*
+                 * Set a timer to put Ethernet to sleep, but only if the screen is off
+                 * AND the "stay on while plugged in" setting doesn't match the
+                 * current power conditions (i.e, not plugged in, plugged in to USB,
+                 * or plugged in to AC).
+                 */
+                if (!shouldEthernetStayAwake(stayAwakeConditions, mPluggedType)) {
+                    //Delayed shutdown if ethernet is connected
+                    if (mNetworkInfo.getDetailedState() == DetailedState.CONNECTED) {
+                        if (DBG) Slog.d(TAG, "setting ACTION_DEVICE_IDLE: " + idleMillis + " ms");
+                        mAlarmManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis()
+                                + idleMillis, mIdleIntent);
+                    } else {
+                        setDeviceIdleAndUpdateEthernet(true);
+                    }
+                }
+            } else if (action.equals(ACTION_DEVICE_IDLE)) {
+                setDeviceIdleAndUpdateEthernet(true);
+            } else if (action.equals(Intent.ACTION_BATTERY_CHANGED)) {
+                /*
+                 * Set a timer to put Ethernet to sleep, but only if the screen is off
+                 * AND we are transitioning from a state in which the device was supposed
+                 * to stay awake to a state in which it is not supposed to stay awake.
+                 * If "stay awake" state is not changing, we do nothing, to avoid resetting
+                 * the already-set timer.
+                 */
+                int pluggedType = intent.getIntExtra("plugged", 0);
+                if (DBG) {
+                    Slog.d(TAG, "ACTION_BATTERY_CHANGED pluggedType: " + pluggedType);
+                }
+                if (mScreenOff && shouldEthernetStayAwake(stayAwakeConditions, mPluggedType) &&
+                        !shouldEthernetStayAwake(stayAwakeConditions, pluggedType)) {
+                    long triggerTime = System.currentTimeMillis() + idleMillis;
+                    if (DBG) {
+                        Slog.d(TAG, "setting ACTION_DEVICE_IDLE timer for " + idleMillis + "ms");
+                    }
+                    mAlarmManager.set(AlarmManager.RTC_WAKEUP, triggerTime, mIdleIntent);
+                }
+
+                mPluggedType = pluggedType;
+            } else if (action.equals(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED)) {
+                mEmergencyCallbackMode = intent.getBooleanExtra("phoneinECMState", false);
+                updateEthernetState();
+            }
+        }
+
+        /**
+         * Determines whether the Ethernet chipset should stay awake or be put to
+         * sleep. Looks at the setting for the sleep policy and the current
+         * conditions.
+         *
+         * @see #shouldDeviceStayAwake(int, int)
+         */
+        private boolean shouldEthernetStayAwake(int stayAwakeConditions, int pluggedType) {
+            //Never sleep as long as the user has not changed the settings
+            int ethernetSleepPolicy = Settings.Global.getInt(mContext.getContentResolver(),
+                    Settings.Global.ETHERNET_SLEEP_POLICY,
+                    Settings.Global.ETHERNET_SLEEP_POLICY_NEVER);
+
+            if (ethernetSleepPolicy == Settings.Global.ETHERNET_SLEEP_POLICY_NEVER) {
+                // Never sleep
+                return true;
+            } else if ((ethernetSleepPolicy == Settings.Global.ETHERNET_SLEEP_POLICY_NEVER_WHILE_PLUGGED) &&
+                    (pluggedType != 0)) {
+                // Never sleep while plugged, and we're plugged
+                return true;
+            } else {
+                // Default
+                return shouldDeviceStayAwake(stayAwakeConditions, pluggedType);
+            }
+        }
+
+        /**
+         * Determine whether the bit value corresponding to {@code pluggedType} is set in
+         * the bit string {@code stayAwakeConditions}. Because a {@code pluggedType} value
+         * of {@code 0} isn't really a plugged type, but rather an indication that the
+         * device isn't plugged in at all, there is no bit value corresponding to a
+         * {@code pluggedType} value of {@code 0}. That is why we shift by
+         * {@code pluggedType - 1} instead of by {@code pluggedType}.
+         * @param stayAwakeConditions a bit string specifying which "plugged types" should
+         * keep the device (and hence Ethernet) awake.
+         * @param pluggedType the type of plug (USB, AC, or none) for which the check is
+         * being made
+         * @return {@code true} if {@code pluggedType} indicates that the device is
+         * supposed to stay awake, {@code false} otherwise.
+         */
+        private boolean shouldDeviceStayAwake(int stayAwakeConditions, int pluggedType) {
+            return (stayAwakeConditions & pluggedType) != 0;
+        }
+    };
+
+    private void setDeviceIdleAndUpdateEthernet(boolean deviceIdle) {
+        mDeviceIdle = deviceIdle;
+        reportStartWorkSource();
+        updateEthernetState();
+    }
+
+    private synchronized void reportStartWorkSource() {
+        mTmpWorkSource.clear();
+        if (mDeviceIdle) {
+            for (int i=0; i<mLocks.mList.size(); i++) {
+                mTmpWorkSource.add(mLocks.mList.get(i).mWorkSource);
+            }
+        }
+        mEthernetStateMachine.updateBatteryWorkSource(mTmpWorkSource);
+    }
+
+    private void updateEthernetState() {
+        boolean lockHeld = mLocks.hasLocks();
+        int strongestLockMode = EthernetManager.ETHERNET_MODE_FULL;
+        boolean ethernetShouldBeStarted;
+
+        if (mEmergencyCallbackMode) {
+            ethernetShouldBeStarted = false;
+        } else {
+            ethernetShouldBeStarted = !mDeviceIdle || lockHeld;
+        }
+
+        if (lockHeld) {
+            strongestLockMode = mLocks.getStrongestLockMode();
+        }
+        /* If device is not idle, lockmode cannot be restricted to Fast-Ethernet only */
+        if (!mDeviceIdle && strongestLockMode == EthernetManager.ETHERNET_MODE_RESTRICTED_FE) {
+            strongestLockMode = EthernetManager.ETHERNET_MODE_FULL;
+        }
+
+        if (shouldEthernetBeEnabled()) {
+            if (ethernetShouldBeStarted) {
+                reportStartWorkSource();
+                mEthernetStateMachine.setEthernetEnabled(true);
+                mEthernetStateMachine.setRestrictedFeMode(
+                        strongestLockMode == EthernetManager.ETHERNET_MODE_RESTRICTED_FE);
+                mEthernetStateMachine.setDriverStart(true, mEmergencyCallbackMode);
+                mEthernetStateMachine.setHighPerfModeEnabled(strongestLockMode
+                        == EthernetManager.ETHERNET_MODE_FULL_HIGH_PERF);
+            } else {
+                mEthernetStateMachine.setDriverStart(false, mEmergencyCallbackMode);
+            }
+        } else {
+            mEthernetStateMachine.setEthernetEnabled(false);
+        }
+    }
+
+    private void registerForBroadcasts() {
+        IntentFilter intentFilter = new IntentFilter();
+        intentFilter.addAction(Intent.ACTION_SCREEN_ON);
+        intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
+        intentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
+        intentFilter.addAction(ACTION_DEVICE_IDLE);
+        intentFilter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
+        mContext.registerReceiver(mReceiver, intentFilter);
+    }
+
+    @Override
+    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP)
+                != PackageManager.PERMISSION_GRANTED) {
+            pw.println("Permission Denial: can't dump EthernetService from from pid="
+                    + Binder.getCallingPid()
+                    + ", uid=" + Binder.getCallingUid());
+            return;
+        }
+        pw.println("Ethernet is " + mEthernetStateMachine.syncGetEthernetStateByName());
+        pw.println("Stay-awake conditions: " +
+                Settings.Global.getInt(mContext.getContentResolver(),
+                                       Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0));
+        pw.println();
+
+        pw.println("Internal state:");
+        pw.println(mEthernetStateMachine);
+        pw.println();
+        pw.println("Locks acquired: " + mFullLocksAcquired + " full, " +
+                mFullHighPerfLocksAcquired + " full high perf, " +
+                mRestrictedFeLocksAcquired + " restricted");
+        pw.println("Locks released: " + mFullLocksReleased + " full, " +
+                mFullHighPerfLocksReleased + " full high perf, " +
+                mRestrictedFeLocksReleased + " restricted");
+        pw.println();
+        pw.println("Locks held:");
+        mLocks.dump(pw);
+
+        pw.println();
+        pw.println("EthernetStateMachine dump");
+        mEthernetStateMachine.dump(fd, pw, args);
+    }
+
+    private class EthernetLock extends DeathRecipient {
+        EthernetLock(int lockMode, String tag, IBinder binder, WorkSource ws) {
+            super(lockMode, tag, binder, ws);
+        }
+
+        public void binderDied() {
+            synchronized (mLocks) {
+                releaseEthernetLockLocked(mBinder);
+            }
+        }
+
+        public String toString() {
+            return "EthernetLock{" + mTag + " type=" + mMode + " binder=" + mBinder + "}";
+        }
+    }
+
+    private class LockList {
+        private List<EthernetLock> mList;
+
+        private LockList() {
+            mList = new ArrayList<EthernetLock>();
+        }
+
+        private synchronized boolean hasLocks() {
+            return !mList.isEmpty();
+        }
+
+        private synchronized int getStrongestLockMode() {
+            if (mList.isEmpty()) {
+                return EthernetManager.ETHERNET_MODE_FULL;
+            }
+
+            if (mFullHighPerfLocksAcquired > mFullHighPerfLocksReleased) {
+                return EthernetManager.ETHERNET_MODE_FULL_HIGH_PERF;
+            }
+
+            if (mFullLocksAcquired > mFullLocksReleased) {
+                return EthernetManager.ETHERNET_MODE_FULL;
+            }
+
+            return EthernetManager.ETHERNET_MODE_RESTRICTED_FE;
+        }
+
+        private void addLock(EthernetLock lock) {
+            if (findLockByBinder(lock.mBinder) < 0) {
+                mList.add(lock);
+            }
+        }
+
+        private EthernetLock removeLock(IBinder binder) {
+            int index = findLockByBinder(binder);
+            if (index >= 0) {
+                EthernetLock ret = mList.remove(index);
+                ret.unlinkDeathRecipient();
+                return ret;
+            } else {
+                return null;
+            }
+        }
+
+        private int findLockByBinder(IBinder binder) {
+            int size = mList.size();
+            for (int i = size - 1; i >= 0; i--)
+                if (mList.get(i).mBinder == binder)
+                    return i;
+            return -1;
+        }
+
+        private void dump(PrintWriter pw) {
+            for (EthernetLock l : mList) {
+                pw.print("    ");
+                pw.println(l);
+            }
+        }
+    }
+
+    void enforceWakeSourcePermission(int uid, int pid) {
+        if (uid == android.os.Process.myUid()) {
+            return;
+        }
+        mContext.enforcePermission(android.Manifest.permission.UPDATE_DEVICE_STATS,
+                pid, uid, null);
+    }
+
+    public boolean acquireEthernetLock(IBinder binder, int lockMode, String tag, WorkSource ws) {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WAKE_LOCK, null);
+        if (lockMode != EthernetManager.ETHERNET_MODE_FULL &&
+                lockMode != EthernetManager.ETHERNET_MODE_RESTRICTED_FE &&
+                lockMode != EthernetManager.ETHERNET_MODE_FULL_HIGH_PERF) {
+            Slog.e(TAG, "Illegal argument, lockMode= " + lockMode);
+            if (DBG) throw new IllegalArgumentException("lockMode=" + lockMode);
+            return false;
+        }
+        if (ws != null && ws.size() == 0) {
+            ws = null;
+        }
+        if (ws != null) {
+            enforceWakeSourcePermission(Binder.getCallingUid(), Binder.getCallingPid());
+        }
+        if (ws == null) {
+            ws = new WorkSource(Binder.getCallingUid());
+        }
+        EthernetLock ethernetLock = new EthernetLock(lockMode, tag, binder, ws);
+        synchronized (mLocks) {
+            return acquireEthernetLockLocked(ethernetLock);
+        }
+    }
+
+    private void noteAcquireEthernetLock(EthernetLock ethernetLock) throws RemoteException {
+        switch(ethernetLock.mMode) {
+            case EthernetManager.ETHERNET_MODE_FULL:
+            case EthernetManager.ETHERNET_MODE_FULL_HIGH_PERF:
+            case EthernetManager.ETHERNET_MODE_RESTRICTED_FE:
+                mBatteryStats.noteFullEthernetLockAcquiredFromSource(ethernetLock.mWorkSource);
+                break;
+        }
+    }
+
+    private void noteReleaseEthernetLock(EthernetLock ethernetLock) throws RemoteException {
+        switch(ethernetLock.mMode) {
+            case EthernetManager.ETHERNET_MODE_FULL:
+            case EthernetManager.ETHERNET_MODE_FULL_HIGH_PERF:
+            case EthernetManager.ETHERNET_MODE_RESTRICTED_FE:
+                mBatteryStats.noteFullEthernetLockReleasedFromSource(ethernetLock.mWorkSource);
+                break;
+        }
+    }
+
+    private boolean acquireEthernetLockLocked(EthernetLock ethernetLock) {
+        if (DBG) Slog.d(TAG, "acquireEthernetLockLocked: " + ethernetLock);
+
+        mLocks.addLock(ethernetLock);
+
+        long ident = Binder.clearCallingIdentity();
+        try {
+            noteAcquireEthernetLock(ethernetLock);
+            switch(ethernetLock.mMode) {
+            case EthernetManager.ETHERNET_MODE_FULL:
+                ++mFullLocksAcquired;
+                break;
+            case EthernetManager.ETHERNET_MODE_FULL_HIGH_PERF:
+                ++mFullHighPerfLocksAcquired;
+                break;
+
+            case EthernetManager.ETHERNET_MODE_RESTRICTED_FE:
+                ++mRestrictedFeLocksAcquired;
+                break;
+            }
+
+            // Be aggressive about adding new locks into the accounted state...
+            // we want to over-report rather than under-report.
+            reportStartWorkSource();
+
+            updateEthernetState();
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    public void updateEthernetLockWorkSource(IBinder lock, WorkSource ws) {
+        int uid = Binder.getCallingUid();
+        int pid = Binder.getCallingPid();
+        if (ws != null && ws.size() == 0) {
+            ws = null;
+        }
+        if (ws != null) {
+            enforceWakeSourcePermission(uid, pid);
+        }
+        long ident = Binder.clearCallingIdentity();
+        try {
+            synchronized (mLocks) {
+                int index = mLocks.findLockByBinder(lock);
+                if (index < 0) {
+                    throw new IllegalArgumentException("Ethernet lock not active");
+                }
+                EthernetLock wl = mLocks.mList.get(index);
+                noteReleaseEthernetLock(wl);
+                wl.mWorkSource = ws != null ? new WorkSource(ws) : new WorkSource(uid);
+                noteAcquireEthernetLock(wl);
+            }
+        } catch (RemoteException e) {
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    public boolean releaseEthernetLock(IBinder lock) {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WAKE_LOCK, null);
+        synchronized (mLocks) {
+            return releaseEthernetLockLocked(lock);
+        }
+    }
+
+    private boolean releaseEthernetLockLocked(IBinder lock) {
+        boolean hadLock;
+
+        EthernetLock ethernetLock = mLocks.removeLock(lock);
+
+        if (DBG) Slog.d(TAG, "releaseEthernetLockLocked: " + ethernetLock);
+
+        hadLock = (ethernetLock != null);
+
+        long ident = Binder.clearCallingIdentity();
+        try {
+            if (hadLock) {
+                noteReleaseEthernetLock(ethernetLock);
+                switch(ethernetLock.mMode) {
+                    case EthernetManager.ETHERNET_MODE_FULL:
+                        ++mFullLocksReleased;
+                        break;
+                    case EthernetManager.ETHERNET_MODE_FULL_HIGH_PERF:
+                        ++mFullHighPerfLocksReleased;
+                        break;
+                    case EthernetManager.ETHERNET_MODE_RESTRICTED_FE:
+                        ++mRestrictedFeLocksReleased;
+                        break;
+                }
+            }
+
+            // TODO - should this only happen if you hadLock?
+            updateEthernetState();
+
+        } catch (RemoteException e) {
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+
+        return hadLock;
+    }
+
+    private abstract class DeathRecipient
+            implements IBinder.DeathRecipient {
+        String mTag;
+        int mMode;
+        IBinder mBinder;
+        WorkSource mWorkSource;
+
+        DeathRecipient(int mode, String tag, IBinder binder, WorkSource ws) {
+            super();
+            mTag = tag;
+            mMode = mode;
+            mBinder = binder;
+            mWorkSource = ws;
+            try {
+                mBinder.linkToDeath(this, 0);
+            } catch (RemoteException e) {
+                binderDied();
+            }
+        }
+
+        void unlinkDeathRecipient() {
+            mBinder.unlinkToDeath(this, 0);
+        }
+    }
+
+    private class Multicaster extends DeathRecipient {
+        Multicaster(String tag, IBinder binder) {
+            super(Binder.getCallingUid(), tag, binder, null);
+        }
+
+        public void binderDied() {
+            Slog.e(TAG, "Multicaster binderDied");
+            synchronized (mMulticasters) {
+                int i = mMulticasters.indexOf(this);
+                if (i != -1) {
+                    removeMulticasterLocked(i, mMode);
+                }
+            }
+        }
+
+        public String toString() {
+            return "Multicaster{" + mTag + " binder=" + mBinder + "}";
+        }
+
+        public int getUid() {
+            return mMode;
+        }
+    }
+
+    public void initializeMulticastFiltering() {
+        enforceMulticastChangePermission();
+
+        synchronized (mMulticasters) {
+            // if anybody had requested filters be off, leave off
+            if (mMulticasters.size() != 0) {
+                return;
+            } else {
+                mEthernetStateMachine.startFilteringMulticastV4Packets();
+            }
+        }
+    }
+
+    public void acquireMulticastLock(IBinder binder, String tag) {
+        enforceMulticastChangePermission();
+
+        synchronized (mMulticasters) {
+            mMulticastEnabled++;
+            mMulticasters.add(new Multicaster(tag, binder));
+            // Note that we could call stopFilteringMulticastV4Packets only when
+            // our new size == 1 (first call), but this function won't
+            // be called often and by making the stopPacket call each
+            // time we're less fragile and self-healing.
+            mEthernetStateMachine.stopFilteringMulticastV4Packets();
+        }
+
+        int uid = Binder.getCallingUid();
+        Long ident = Binder.clearCallingIdentity();
+        try {
+            mBatteryStats.noteEthernetMulticastEnabled(uid);
+        } catch (RemoteException e) {
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    public void releaseMulticastLock() {
+        enforceMulticastChangePermission();
+
+        int uid = Binder.getCallingUid();
+        synchronized (mMulticasters) {
+            mMulticastDisabled++;
+            int size = mMulticasters.size();
+            for (int i = size - 1; i >= 0; i--) {
+                Multicaster m = mMulticasters.get(i);
+                if ((m != null) && (m.getUid() == uid)) {
+                    removeMulticasterLocked(i, uid);
+                }
+            }
+        }
+    }
+
+    private void removeMulticasterLocked(int i, int uid)
+    {
+        Multicaster removed = mMulticasters.remove(i);
+
+        if (removed != null) {
+            removed.unlinkDeathRecipient();
+        }
+        if (mMulticasters.size() == 0) {
+            mEthernetStateMachine.startFilteringMulticastV4Packets();
+        }
+
+        Long ident = Binder.clearCallingIdentity();
+        try {
+            mBatteryStats.noteEthernetMulticastDisabled(uid);
+        } catch (RemoteException e) {
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    public boolean isMulticastEnabled() {
+        enforceAccessPermission();
+
+        synchronized (mMulticasters) {
+            return (mMulticasters.size() > 0);
+        }
+    }
+
+    /**
+     * Evaluate if traffic stats polling is needed based on
+     * connection and screen on status
+     */
+    private void evaluateTrafficStatsPolling() {
+        Message msg;
+        if (mNetworkInfo.getDetailedState() == DetailedState.CONNECTED && !mScreenOff) {
+            msg = Message.obtain(mAsyncServiceHandler,
+                    EthernetManager.ENABLE_TRAFFIC_STATS_POLL, 1, 0);
+        } else {
+            msg = Message.obtain(mAsyncServiceHandler,
+                    EthernetManager.ENABLE_TRAFFIC_STATS_POLL, 0, 0);
+        }
+        msg.sendToTarget();
+    }
+
+    private void notifyOnDataActivity() {
+        long sent, received;
+        long preTxPkts = mTxPkts, preRxPkts = mRxPkts;
+        int dataActivity = EthernetManager.DATA_ACTIVITY_NONE;
+
+        mTxPkts = TrafficStats.getTxPackets(mInterfaceName);
+        mRxPkts = TrafficStats.getRxPackets(mInterfaceName);
+
+        if (preTxPkts > 0 || preRxPkts > 0) {
+            sent = mTxPkts - preTxPkts;
+            received = mRxPkts - preRxPkts;
+            if (sent > 0) {
+                dataActivity |= EthernetManager.DATA_ACTIVITY_OUT;
+            }
+            if (received > 0) {
+                dataActivity |= EthernetManager.DATA_ACTIVITY_IN;
+            }
+
+            if (dataActivity != mDataActivity && !mScreenOff) {
+                mDataActivity = dataActivity;
+                for (AsyncChannel client : mClients) {
+                    client.sendMessage(EthernetManager.DATA_ACTIVITY_NOTIFICATION, mDataActivity);
+                }
+            }
+        }
+    }
+}
diff --git a/services/java/com/android/server/connectivity/Tethering.java b/services/java/com/android/server/connectivity/Tethering.java
index e4a7ead..31d3b04 100644
--- a/services/java/com/android/server/connectivity/Tethering.java
+++ b/services/java/com/android/server/connectivity/Tethering.java
@@ -81,6 +81,7 @@ public class Tethering extends INetworkManagementEventObserver.Stub {
     // TODO - remove both of these - should be part of interface inspection/selection stuff
     private String[] mTetherableUsbRegexs;
     private String[] mTetherableWifiRegexs;
+    private String[] mTetherableEthernetRegexs;
     private String[] mTetherableBluetoothRegexs;
     private Collection<Integer> mUpstreamIfaceTypes;
 
@@ -112,13 +113,14 @@ public class Tethering extends INetworkManagementEventObserver.Stub {
     // Wifi is 192.168.43.1 and 255.255.255.0
     // BT is limited to max default of 5 connections. 192.168.44.1 to 192.168.48.1
     // with 255.255.255.0
+    // Ethernet is 192.168.49.1 and 255.255.255.0
 
     private String[] mDhcpRange;
     private static final String[] DHCP_DEFAULT_RANGE = {
         "192.168.42.2", "192.168.42.254", "192.168.43.2", "192.168.43.254",
         "192.168.44.2", "192.168.44.254", "192.168.45.2", "192.168.45.254",
         "192.168.46.2", "192.168.46.254", "192.168.47.2", "192.168.47.254",
-        "192.168.48.2", "192.168.48.254",
+        "192.168.48.2", "192.168.48.254", "192.168.49.2", "192.168.49.254",
     };
 
     private String[] mDefaultDnsServers;
@@ -184,6 +186,8 @@ public class Tethering extends INetworkManagementEventObserver.Stub {
                 com.android.internal.R.array.config_tether_usb_regexs);
         String[] tetherableWifiRegexs = mContext.getResources().getStringArray(
                 com.android.internal.R.array.config_tether_wifi_regexs);
+        String[] tetherableEthernetRegexs = mContext.getResources().getStringArray(
+                com.android.internal.R.array.config_tether_ethernet_regexs);
         String[] tetherableBluetoothRegexs = mContext.getResources().getStringArray(
                 com.android.internal.R.array.config_tether_bluetooth_regexs);
 
@@ -197,6 +201,7 @@ public class Tethering extends INetworkManagementEventObserver.Stub {
         synchronized (mPublicSync) {
             mTetherableUsbRegexs = tetherableUsbRegexs;
             mTetherableWifiRegexs = tetherableWifiRegexs;
+            mTetherableEthernetRegexs = tetherableEthernetRegexs;
             mTetherableBluetoothRegexs = tetherableBluetoothRegexs;
             mUpstreamIfaceTypes = upstreamIfaceTypes;
         }
@@ -212,6 +217,8 @@ public class Tethering extends INetworkManagementEventObserver.Stub {
         synchronized (mPublicSync) {
             if (isWifi(iface)) {
                 found = true;
+	    } else if (isEthernet(iface)) {
+                found = true;
             } else if (isUsb(iface)) {
                 found = true;
                 usb = true;
@@ -263,6 +270,15 @@ public class Tethering extends INetworkManagementEventObserver.Stub {
         }
     }
 
+    public boolean isEthernet(String iface) {
+        synchronized (mPublicSync) {
+            for (String regex : mTetherableEthernetRegexs) {
+                if (iface.matches(regex)) return true;
+            }
+            return false;
+        }
+    }
+
     public boolean isBluetooth(String iface) {
         synchronized (mPublicSync) {
             for (String regex : mTetherableBluetoothRegexs) {
@@ -280,6 +296,9 @@ public class Tethering extends INetworkManagementEventObserver.Stub {
             if (isWifi(iface)) {
                 found = true;
             }
+	    if (isEthernet(iface)) {
+                found = true;
+            }
             if (isUsb(iface)) {
                 found = true;
                 usb = true;
@@ -385,6 +404,7 @@ public class Tethering extends INetworkManagementEventObserver.Stub {
         ArrayList<String> erroredList = new ArrayList<String>();
 
         boolean wifiTethered = false;
+        boolean ethernetTethered = false;
         boolean usbTethered = false;
         boolean bluetoothTethered = false;
 
@@ -402,6 +422,8 @@ public class Tethering extends INetworkManagementEventObserver.Stub {
                             usbTethered = true;
                         } else if (isWifi((String)iface)) {
                             wifiTethered = true;
+                        } else if (isEthernet((String)iface)) {
+                            ethernetTethered = true;
                       } else if (isBluetooth((String)iface)) {
                             bluetoothTethered = true;
                         }
@@ -425,7 +447,7 @@ public class Tethering extends INetworkManagementEventObserver.Stub {
         }
 
         if (usbTethered) {
-            if (wifiTethered || bluetoothTethered) {
+            if (wifiTethered || ethernetTethered || bluetoothTethered) {
                 showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
             } else {
                 showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_usb);
@@ -436,6 +458,8 @@ public class Tethering extends INetworkManagementEventObserver.Stub {
             } else {
                 showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_wifi);
             }
+        } else if (ethernetTethered) {
+            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
         } else if (bluetoothTethered) {
             showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_bluetooth);
         } else {
@@ -587,6 +611,10 @@ public class Tethering extends INetworkManagementEventObserver.Stub {
         return mTetherableWifiRegexs;
     }
 
+    public String[] getTetherableEthernetRegexs() {
+        return mTetherableEthernetRegexs;
+    }
+
     public String[] getTetherableBluetoothRegexs() {
         return mTetherableBluetoothRegexs;
     }
diff --git a/tools/aapt/Command.cpp b/tools/aapt/Command.cpp
index 0a5e590..32fdcde 100644
--- a/tools/aapt/Command.cpp
+++ b/tools/aapt/Command.cpp
@@ -671,6 +671,8 @@ int doDump(Bundle* bundle)
             bool hasRecordAudioPermission = false;
             bool specWiFiFeature = false;
             bool hasWiFiPermission = false;
+            bool specEthernetFeature = false;
+            bool hasEthernetPermission = false;
             bool specTelephonyFeature = false; // telephony-related
             bool reqTelephonySubFeature = false;
             bool hasTelephonyPermission = false;
@@ -960,6 +962,8 @@ int doDump(Bundle* bundle)
                                 specMicrophoneFeature = true;
                             } else if (name == "android.hardware.wifi") {
                                 specWiFiFeature = true;
+                            } else if (name == "android.hardware.ethernet") {
+                                specEthernetFeature = true;
                             } else if (name == "android.hardware.telephony") {
                                 specTelephonyFeature = true;
                             } else if (req && (name == "android.hardware.telephony.gsm" ||
@@ -1004,6 +1008,10 @@ int doDump(Bundle* bundle)
                                        name == "android.permission.CHANGE_WIFI_STATE" ||
                                        name == "android.permission.CHANGE_WIFI_MULTICAST_STATE") {
                                 hasWiFiPermission = true;
+                            } else if (name == "android.permission.ACCESS_ETHERNET_STATE" ||
+                                       name == "android.permission.CHANGE_ETHERNET_STATE" ||
+                                       name == "android.permission.CHANGE_ETHERNET_MULTICAST_STATE") {
+                                hasEthernetPermission = true;
                             } else if (name == "android.permission.CALL_PHONE" ||
                                        name == "android.permission.CALL_PRIVILEGED" ||
                                        name == "android.permission.MODIFY_PHONE_STATE" ||
@@ -1315,6 +1323,17 @@ int doDump(Bundle* bundle)
                         "android.permission.CHANGE_WIFI_MULTICAST_STATE permission'\n");
             }
 
+            // Ethernet-related compatibility logic
+            if (!specEthernetFeature && hasEthernetPermission) {
+                // if app takes one of the Ethernet permissions but does not request the Ethernet
+                // feature, we infer that it meant to
+                printf("uses-feature:'android.hardware.ethernet'\n");
+                printf("uses-implied-feature:'android.hardware.ethernet'," \
+                        "'requested android.permission.ACCESS_ETHERNET_STATE, " \
+                        "android.permission.CHANGE_ETHERNET_STATE, or " \
+                        "android.permission.CHANGE_ETHERNET_MULTICAST_STATE permission'\n");
+            }
+
             // Telephony-related compatibility logic
             if (!specTelephonyFeature && (hasTelephonyPermission || reqTelephonySubFeature)) {
                 // if app takes one of the telephony permissions or requests a sub-feature but
diff --git a/voip/java/android/net/sip/SipManager.java b/voip/java/android/net/sip/SipManager.java
index 74c3672..88d2aa5 100644
--- a/voip/java/android/net/sip/SipManager.java
+++ b/voip/java/android/net/sip/SipManager.java
@@ -155,6 +155,14 @@ public class SipManager {
                 com.android.internal.R.bool.config_sip_wifi_only);
     }
 
+    /**
+     * Returns true if SIP is only available on Ethernet.
+     */
+    public static boolean isSipEthernetOnly(Context context) {
+        return context.getResources().getBoolean(
+                com.android.internal.R.bool.config_sip_ethernet_only);
+    }
+
     private SipManager(Context context) {
         mContext = context;
         createSipService();
diff --git a/voip/java/com/android/server/sip/SipService.java b/voip/java/com/android/server/sip/SipService.java
index a477fd1..b3a38ae 100644
--- a/voip/java/com/android/server/sip/SipService.java
+++ b/voip/java/com/android/server/sip/SipService.java
@@ -81,6 +81,7 @@ public final class SipService extends ISipService.Stub {
     private SipWakeupTimer mTimer;
     private WifiManager.WifiLock mWifiLock;
     private boolean mSipOnWifiOnly;
+    private boolean mSipOnEthernetOnly;
 
     private IntervalMeasurementProcess mIntervalMeasurementProcess;
 
@@ -122,6 +123,8 @@ public final class SipService extends ISipService.Stub {
         mWifiLock.setReferenceCounted(false);
         mSipOnWifiOnly = SipManager.isSipWifiOnly(context);
 
+        mSipOnEthernetOnly = SipManager.isSipEthernetOnly(context);
+
         mMyWakeLock = new SipWakeLock((PowerManager)
                 context.getSystemService(Context.POWER_SERVICE));
 
@@ -1125,7 +1128,8 @@ public final class SipService extends ISipService.Stub {
         // Some devices limit SIP on Wi-Fi. In this case, if we are not on
         // Wi-Fi, treat it as a DISCONNECTED event.
         int networkType = (info != null && info.isConnected()) ? info.getType() : -1;
-        if (mSipOnWifiOnly && networkType != ConnectivityManager.TYPE_WIFI) {
+        if ((mSipOnWifiOnly && networkType != ConnectivityManager.TYPE_WIFI) ||
+	    (mSipOnEthernetOnly && networkType != ConnectivityManager.TYPE_ETHERNET)) {
             networkType = -1;
         }
 
